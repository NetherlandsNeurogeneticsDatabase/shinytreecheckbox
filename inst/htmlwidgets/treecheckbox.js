/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./srcjs/modules/tree.css":
/*!**************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./srcjs/modules/tree.css ***!
  \**************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Style the caret/arrow */\n.UNwkxeu8JaLUR7zsLOLc {\n  cursor: pointer;\n  user-select: none; /* Prevent text selection */\n  display: inline-block;\n  margin-right: 6px;\n}\n\n.dpG9VJCbE1T3hvNqWAXQ {\n  list-style: none;\n}\n\n.fRDpmJJ9MRXanERdlguP {\n  background-color: white;\n  border-radius: 8px;\n  border: 1px solid #cccccc;\n  max-height: 25vh;\n}\n\n.GmtEMuE1BhBuOK4UDeoJ {\n  margin: 0;\n  border: 0;\n  background-color: transparent;\n  max-height: 18px;\n  display: inline-flex;\n  vertical-align: middle;\n  line-height: 16px;\n  padding: 0 2px 0 0;\n}\n\n.GmtEMuE1BhBuOK4UDeoJ:hover {\n  width: fit-content;\n  height: fit-content;\n  min-width: 16px;\n  min-height: 16px;\n  outline: none;\n}\n\n.pa5_k8SKSgRfWLTMfIfH {\n  border: 1px solid #cccccc;\n  border-left: 0;\n  display: none;\n  border-radius: 0 3px 3px 0;\n}\n\n.qIPVtNod_iQXqPR5gItw {\n  border-radius: 4px;\n  border-color: orange;\n  border-style: solid;\n  border-width: 1.17px;\n  color: orange;\n}\n\n.qIPVtNod_iQXqPR5gItw:hover {\n  width: 16px;\n  height: 16px;\n  padding: 1px;\n  border-radius: 4px;\n  border-color: orange;\n  border-style: solid;\n  border-width: 1.17px;\n  color: orange;\n}\n\n/*# sourceMappingURL=tree.css.map */\n", "",{"version":3,"sources":["webpack://./srcjs/modules/tree.scss","webpack://./srcjs/modules/tree.css"],"names":[],"mappings":"AACA,0BAAA;AACA;EACE,eAAA;EACA,iBAAA,EAAA,2BAAA;EACA,qBAAA;EACA,iBAAA;ACAF;;ADGA;EACE,gBAAA;ACAF;;ADGA;EACE,uBAAA;EACA,kBAAA;EACA,yBAAA;EACA,gBAAA;ACAF;;ADIA;EACI,SAAA;EACA,SAAA;EACA,6BAAA;EACA,gBAAA;EACA,oBAAA;EACA,sBAAA;EACA,iBAAA;EACA,kBAAA;ACDJ;;ADIA;EACE,kBAAA;EACA,mBAAA;EACA,eAAA;EACA,gBAAA;EACA,aAAA;ACDF;;ADIA;EACI,yBAAA;EACA,cAAA;EACA,aAAA;EACA,0BAAA;ACDJ;;ADMA;EACE,kBAAA;EACA,oBAAA;EACA,mBAAA;EACA,oBAAA;EACA,aAAA;ACHF;;ADMA;EACE,WAAA;EACA,YAAA;EACA,YAAA;EACA,kBAAA;EACA,oBAAA;EACA,mBAAA;EACA,oBAAA;EACA,aAAA;ACHF;;AAEA,mCAAmC","sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"groupedCheckboxCaret": "UNwkxeu8JaLUR7zsLOLc",
	"groupedCheckboxList": "dpG9VJCbE1T3hvNqWAXQ",
	"groupedCheckboxNodeHolder": "fRDpmJJ9MRXanERdlguP",
	"btnInclude": "GmtEMuE1BhBuOK4UDeoJ",
	"btnHelpLabel": "pa5_k8SKSgRfWLTMfIfH",
	"btnIndeterminate": "qIPVtNod_iQXqPR5gItw"
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./srcjs/modules/tree.css":
/*!********************************!*\
  !*** ./srcjs/modules/tree.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./tree.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./srcjs/modules/tree.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./srcjs/modules/constructTree.js":
/*!****************************************!*\
  !*** ./srcjs/modules/constructTree.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstructTree": () => (/* binding */ ConstructTree)
/* harmony export */ });


/* The ConstructTree class takes in a list of records and a list of levels, and builds a tree of nodes
where each node represents a level and each node's children represent the next level */
class ConstructTree {
    root
    constructor(data, levels) {
        this.buildTree(data, levels)
    }


/**
 * > The function takes in a data set and a list of levels, and builds a tree with the data set
 * @param data - the data you want to build the tree from
 * @param levels - an array of strings that represent the levels of the tree.
 */
    buildTree(data, levels){
        let root = new Node("root")
        let newData

        data.forEach(record => {
            newData = []
            levels.forEach(level => {
                newData.push(record[level])
            })
            this.#findOrAppend(root, newData)
        })
        this.root = root
    }

/**
 * Returns the max depth of the tree
 * @returns The depth of the tree
 */
    findMaxDepth(){
        let queue = []
        let depth = 0

        queue.push(this.root)

        while(queue.length > 0){
            let size = queue.length

            let current

            for (let i = 0; i < size ; i++){
                current = queue.shift()

                for (let child of current.children){
                    queue.push(child)
                }
            }
            depth ++
        }
        return depth - 1
    }

/**
 * > Given a tree and a list of values, find the node in the tree that matches the last value in the
 * list, and if it doesn't exist, create it
 * @param tree - the tree to search
 * @param values - an array of values to be added to the tree
 * @returns The tree with the new values added.
 */
    #findOrAppend(tree, values){
        for (let i = 0; i < values.length ; i++){
            let keyQueue = values.slice(0, i + 1)
            let value = values[i]
            let [nodeIn, _] = this.#recursiveSearch(tree, keyQueue)
            if (nodeIn.value !== value){
                let newNode = new Node(value)
                nodeIn.add_child(newNode)
            }
        }
        return(tree)
    }
    
/**
 * > The function takes a node and a list of values to find. It returns the node that matches the last
 * value in the list, and the list of values that were not found
 * @param node - the node that we are currently searching
 * @param find - an array of strings that represent the path to the node you want to find
 * @returns The node that is the last in the path, and the path that is left to be searched.
 */
    #recursiveSearch(node, find){
        let children = node.children
        for (const child of children) {
            let finding = find[0]
            if (finding === child.value){
                find.shift()
                if (find.length > 0){
                    return this.#recursiveSearch(child, find)
                } else {
                    return([child, find])
                }
            }
        }
        return [node, find]
    }


}


/* A node is a value, a list of children, and a parent */
class Node{
    constructor(value, children, parent) {
        if (!children){
            children = []
        }
        this.value = value
        this.children = children
        this.parent = parent
        this.depth = 0
    }

    /*
     * Add children to node, and register parent in child.
     */
    add_child(child){
        this.children.push(child)
        this.children.forEach(child => {
            child.addParent(this)
        })
    }

    addParent(parent){
        this.parent = parent
        this.depth = parent.depth + 1
    }

    get has_children(){
        return((this.children.length > 0))
    }

    get siblings(){
        return this.parent.children
    }

    findObjectByName(name){
        if (this.value === name){
            return this
        } else {
            for (const child of this.children){
                let match = child.findObjectByName(name)
                if (match){
                    return match
                }
            }
        }
    }
}




/***/ }),

/***/ "./srcjs/modules/helpers.js":
/*!**********************************!*\
  !*** ./srcjs/modules/helpers.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCaret": () => (/* binding */ createCaret),
/* harmony export */   "createCheckboxLabel": () => (/* binding */ createCheckboxLabel),
/* harmony export */   "createInputCheckbox": () => (/* binding */ createInputCheckbox),
/* harmony export */   "generateID": () => (/* binding */ generateID),
/* harmony export */   "generateSelectButtons": () => (/* binding */ generateSelectButtons)
/* harmony export */ });
/* harmony import */ var _tree_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree.css */ "./srcjs/modules/tree.css");


/* A function that generates a unique ID. */
let generateID = (function(n) {
    return function() {
        n += 1
        return n;
    }
}(-1))


/**
 * It creates a span element, adds the class `groupedCheckboxCaret` to it, and sets its inner text to
 * "▼".
 * @returns A span element with the class "groupedCheckboxCaret" and the inner text "▼"
 */
 function createCaret(){
    let caret = document.createElement("span")
    caret.classList.add(_tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].groupedCheckboxCaret)
    caret.innerText = "▼"
    return(caret)
}


/**
 * It creates a checkbox input element
 * @param nodeName - The name of the node
 * @param nodeID - The ID of the node.
 * @returns The inputCheckbox element
 */
 function createInputCheckbox(nodeName, nodeID) {
    let inputCheckbox = document.createElement("input")
    inputCheckbox.classList.add("grouped-checkbox-input", "form-check-input")
    inputCheckbox.type = "checkbox"
    inputCheckbox.value = nodeName
    inputCheckbox.id = "node-input-check" + nodeID
    return(inputCheckbox)
}

/**
 * It creates a label for a checkbox
 * @param nodeName - the name of the node
 * @param id - the id of the node
 * @returns A label element
 */
function createCheckboxLabel(nodeName, id){
    let labelCheckbox = document.createElement("label")
    labelCheckbox.classList.add("form-check-label")
    labelCheckbox.for = "node-input-check" + id
    labelCheckbox.innerHTML = nodeName
    return(labelCheckbox)
}

/**
 * It generates a container with two buttons, one to select all checkboxes and one to deselect all
 * checkboxes
 * @returns A div with two buttons.
 */
function generateSelectButtons(id, isHierarchical, includeMode){

    let $container = $("<div>", {"class": "d-flex justify-content-evenly"})

    let generatedID = generateID()

    let $dropdown = $("<div>", {"class": "dropdown"})

    if (includeMode === true){
        let $dropDownSelectButton = $("<button>", {"class": "btn btn-outline-fg dropdown-toggle ", "type": "button", "id": "dropDownSelect-" + generatedID})
            .text("(de)select all")
            .attr("data-bs-toggle", "dropdown")
            .attr("aria-expanded", "false")
        $dropdown.append($dropDownSelectButton)

        // Create dropdown menu for the dropdownSelect button
        let dropDownSelectMenu = $("<ul>", {"class": "dropdown-menu", "aria-labelledby": "dropDownSelect-" + generatedID})
        dropDownSelectMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-include-all"}).text("Include all")))
        dropDownSelectMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-exclude-all"}).text("Exclude all")))
        dropDownSelectMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-deselect-all"}).text("Deselect all")))

        $dropdown.append(dropDownSelectMenu)
        $container.append($dropdown)

    } else {
        // We want to render the (de)select all buttons here.
        let dropDownSelectButton = $("<button>", {"class": "btn btn-outline-fg dropdown-toggle ", "type": "button", "id": "dropDownSelect-" + generatedID})
            .text("(de)select all")
            .attr("data-bs-toggle", "dropdown")
            .attr("aria-expanded", "false")
        $dropdown.append(dropDownSelectButton)

        // Create dropdown menu for the dropdownSelect button
        let dropDownSelectMenu = $("<ul>", {"class": "dropdown-menu", "aria-labelledby": "dropDownSelect-" + generatedID})
        dropDownSelectMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-select-all"}).text("Select all")))
        dropDownSelectMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-deselect-all"}).text("Deselect all")))

        $dropdown.append(dropDownSelectMenu)
        $container.append($dropdown)
    }

    if (isHierarchical === true){
            // Generate collapse menu
            $dropdown = $("<div>", {"class": "dropdown"})
            let $dropDownCollapseButton = $("<button>", {"class": "btn btn-outline-fg dropdown-toggle ", "type": "button", "id": "dropDownCollapse-" + generatedID})
                .text("collapse")
                .attr("data-bs-toggle", "dropdown")
                .attr("aria-expanded", "false")
            $dropdown.append($dropDownCollapseButton)

            // Create dropdown menu for the dropdownCollapse button
            let $dropDownCollapseMenu = $("<ul>", {"class": "dropdown-menu", "aria-labelledby": "dropDownCollapse-" + generatedID})
            $dropDownCollapseMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-collapse-all"}).text("Collapse all")))
            $dropDownCollapseMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-expand-all"}).text("Expand all")))
            $dropdown.append($dropDownCollapseMenu)
            $container.append($dropdown)
    }

    //
    // // get mode
    //
    // if (renderIncluded){
    //     // Generate collapse menu
    //     dropdown = $("<div>", {"class": "dropdown"})
    //     let dropDownCollapseButton = $("<button>", {"class": "btn btn-outline-fg dropdown-toggle ", "type": "button", "id": "dropDownCollapse-" + generatedID})
    //         .text("collapse")
    //         .attr("data-bs-toggle", "dropdown")
    //         .attr("aria-expanded", "false")
    //     dropdown.append(dropDownCollapseButton)
    //
    //     // Create dropdown menu for the dropdownCollapse button
    //     let dropDownCollapseMenu = $("<ul>", {"class": "dropdown-menu", "aria-labelledby": "dropDownCollapse-" + generatedID})
    //     dropDownCollapseMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-collapse-all"}).text("Collapse all")))
    //     dropDownCollapseMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-expand-all"}).text("Expand all")))
    //     dropdown.append(dropDownCollapseMenu)
    //     container.append(dropdown)
    // }
    //
    // if (renderIncluded){
    //     // Generate include menu
    //     dropdown = $("<div>", {"class": "dropdown"})
    //     let dropDownIncludeButton = $("<button>", {"class": "btn btn-outline-fg dropdown-toggle ", "type": "button", "id": "dropDownInclude-" + generatedID})
    //         .text("include")
    //         .attr("data-bs-toggle", "dropdown")
    //         .attr("aria-expanded", "false")
    //     dropdown.append(dropDownIncludeButton)
    //
    //     // Create dropdown menu for the dropdownInclude button
    //     let dropDownIncludeMenu = $("<ul>", {"class": "dropdown-menu", "aria-labelledby": "dropDownInclude-" + generatedID})
    //     dropDownIncludeMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-include-all"}).text("Include all")))
    //     dropDownIncludeMenu.append($("<li>", {"class": "dropdown-item"}).append($("<a>", {"class": "dropdown-link grouped-checkbox-exclude-all"}).text("Exclude all")))
    //     dropdown.append(dropDownIncludeMenu)
    //     container.append(dropdown)
    // }
    return($container)
}



/***/ }),

/***/ "./srcjs/modules/multiStateCheckbox.js":
/*!*********************************************!*\
  !*** ./srcjs/modules/multiStateCheckbox.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generateMultiStateCheckbox": () => (/* binding */ generateMultiStateCheckbox),
/* harmony export */   "setStateOfButton": () => (/* binding */ setStateOfButton)
/* harmony export */ });
/* harmony import */ var _tree_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree.css */ "./srcjs/modules/tree.css");



const defaultStates = {
    "unchecked": {
        "symbol":
            '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-square" viewBox="0 0 16 16">\n' +
            '  <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>\n' +
            '</svg>',
        "textColour": "text-dark",
        "spanClasses": "bg-dark text-white",
        "value": 0
    },
    "include": {
        "symbol":
            '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-square" viewBox="0 0 16 16">\n' +
            '  <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>\n' +
            '  <path d="M10.97 4.97a.75.75 0 0 1 1.071 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.235.235 0 0 1 .02-.022z"/>\n' +
            '</svg>',
        "textColour": "text-success",
        "spanClasses": "bg-success text-white",
        "value": "include"

    }, "exclude": {
        "symbol":
            '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-x-square" viewBox="0 0 16 16"><path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>',
        "textColour": "text-danger",
        "spanClasses": "bg-danger text-white",
        "value": "exclude"

    },"indeterminate": {
        "symbol":
            '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-dash-square" viewBox="0 0 16 16">\n' +
            '  <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>\n' +
            '  <path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>\n' +
            '</svg>',
        "textColour": "text-warning",
        "spanClasses": "bg-warning text-white",
        "value": 0
    }
}

function generateMultiStateCheckbox(value, initState, states=defaultStates) {
    if(!Object.keys(states).includes(initState)){
        throw new Error("Invalid initial state")
    }

    let state = states[initState]

    let $includeButton = $("<button>", {"class": _tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnInclude, "aria-label": initState, "value": value, data: {state: initState}})
        .append($("<span>", {"class": state.textColour, html: state.symbol}))
        .append($("<span>", {"class": state.spanClasses + " " + _tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnHelpLabel, text: state.value}).hide())


    // Add events to button
    setMultiStateCheckboxLogic($includeButton, states)

    return $includeButton.get(0)
}


function setParentIndeterminate(button, parentButton, states) {
    let ownState = button.value //
    let siblings = button.parent().parent().siblings().children("span").children("button")


    let siblingStates = siblings.map(function(){return this.value})

    if(siblingStates.toArray().every(state => state === ownState)){
        setStateOfButton(parentButton, ownState, states)
    } else {
        setStateOfButton(parentButton, "indeterminate", states)
    }
}

function setMultiStateCheckboxLogic($button, states=defaultStates) {
    $button.on("click", function () {
        let $clickedButton = $(this)
        let newStage = setNextStage($clickedButton, states)

        // Change children to the same state
        setStateOfChildren($clickedButton, newStage, states)

        let $parentButton = $clickedButton.parent().parent().parent().siblings("button")
        if ($parentButton.length > 0) {
            setParentIndeterminate($clickedButton, $parentButton, states)
        }
    })

    // On mouseover, show the text
    $button.on("mouseover", function () {
        // Create a timeout to prevent the text from showing when the user is just moving the mouse
        let $clickedButton = $(this)
        let timeout = setTimeout(function () {
            let $typeLabel = $clickedButton.children("." + _tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnHelpLabel)

            if ($clickedButton.data("textValue") === 0) {
                $typeLabel.hide()
            } else {
                $typeLabel.show()
            }
        }, 500)
        $button.data("timeout", timeout)
    })

    // On mouseout, hide the text
    $button.on("mouseout", function () {
        clearTimeout($(this).data("timeout"))
        let text = $(this).children("." + _tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnHelpLabel)
        text.hide()
    })

}

function setStateOfButton($button, state, states=defaultStates) {
    if(!Object.keys(states).includes(state)){
        throw new Error("Invalid state")
    }

    // Update the button to its new state
    $button.attr("aria-label", state)
        .data("state", state)
        .data("textValue", states[state].value)
        .attr("class", _tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnInclude)
        .addClass(states[state].textColour)

    // Update the icon
    let $icon = $button.find("span").first().attr("class", states[state].textColour)

    // Update the symbol
    $icon.empty()
    $icon.append($(states[state].symbol, {"class": states[state].textColour}))

    // Update the text
    $button.find("span").last()
        .text(states[state].value)
        .attr("class", states[state].spanClasses + " " +_tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnHelpLabel)
        .hide()
}

function setStateOfChildren($button, state, states=defaultStates){
    // Get all the buttons in the unordered list with the class styles.btnInclude
    let buttons = $button.siblings("ul").find("." + _tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].btnInclude)
    buttons.each(function(){
        setStateOfButton($(this), state, states)
    })
}

function setNextStage($button, states) {

    let stateKey = $button.data("state")

    if(!Object.keys(states).includes(stateKey)){
        throw new Error("Invalid state")
    }

    // Create an array of the states and get the index of the current state, so we can determine the next state
    let stateKeys = Object.keys(states)
    let stateIndex = stateKeys.indexOf(stateKey)

    // determine the next state
    let nextState = stateKeys[(stateIndex + 1) % stateKeys.length]

    while(nextState === "indeterminate"){
        stateIndex = stateKeys.indexOf(nextState)
        nextState = stateKeys[(stateIndex + 1) % stateKeys.length]
    }

    // Change the state of the button
    setStateOfButton($button, nextState, states)
    return nextState
}


/***/ }),

/***/ "./srcjs/modules/renderTree.js":
/*!*************************************!*\
  !*** ./srcjs/modules/renderTree.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTree": () => (/* binding */ createTree)
/* harmony export */ });
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiny */ "shiny");
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shiny__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constructTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructTree */ "./srcjs/modules/constructTree.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./srcjs/modules/helpers.js");
/* harmony import */ var _multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./multiStateCheckbox */ "./srcjs/modules/multiStateCheckbox.js");
/* harmony import */ var _tree_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tree.css */ "./srcjs/modules/tree.css");







function preSelectNodes(id, selected, includeMode) {
    let $base = $("#" + id)

    if (typeof(selected) === "boolean" && selected === true){
        if (includeMode === true){
            $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude).each(function(){
                (0,_multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__.setStateOfButton)(this, "include")
            })
        } else {
            $base.find(".grouped-checkbox-input").prop({indeterminate: false, checked: true})}
    }

    else{

        // If selected is a string put it into an array
        if (typeof(selected) === "string"){
            selected = [selected]
        }

        for (let value of selected){
            // Add backslash to value to escape special characters
            value = value.replace(/([ #;&,.+*~\':"!^$[\]()=>|\/@])/g, '\\$1')

            if (includeMode === true){
                console.log("includeMode: " + includeMode + " value: " + value)
                let button = $base.find("input[value='" + value + "']").siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude)
                ;(0,_multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__.setStateOfButton)(button, "include")
            } else {
                console.log("includeMode: " + includeMode + " value: " + value)

                // bind the class 'grouped-checkbox-input' to the input element
                $base.find("input[value='" + value + "']").prop({indeterminate: false, checked: true})


                // $base.find(".grouped-checkbox-input[value='" + value + "']").prop({indeterminate: false, checked: true})
            }

        }
    }
}

function collapseNodes(id, collapsed) {
    if (typeof(collapsed) === "boolean" && collapsed){
        $("#" + id).find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxCaret).each(function(){
            hideListElement(this, "toggle")
        })
    } else if (Array.isArray(collapsed) || typeof(collapsed) === "string"){
        if (typeof(collapsed) === "string"){
            collapsed = [collapsed]
        }

        for (let value of collapsed){

            // Make sure to escape special characters
            value = value.replace(/([ #;&,.+*~\':"!^$[\]()=>|\/@])/g, '\\$1')

            let caret = $("#" + id).find("input[value='" + value + "']").siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxCaret);
            hideListElement(caret, "toggle")
        }

    }
}

/**
 * It takes a bunch of inputs, creates a tree, and then renders it
 * @param id - The id of the element that will hold the tree
 * @param label - The label for the tree
 * @param choices - A list of choices. Each choice is a list of length 2, where the first element is
 * the value of the choice, and the second element is the label.
 * @param levels - A vector of strings that indicate the levels of the tree.
 * @param collapsed - a boolean that determines whether the tree should be collapsed by default
 * @param selected - A vector of values that should be selected, If provided true.
 * @param includeMode - A boolean that determines whether the checkboxes have an include/exclude mode
 * @param renderSelectButtons - A boolean that determines whether the select buttons should be rendered
 * @param renderSearchBar - A boolean that determines whether the search bar should be rendered
 */
function createTree(id, label, choices, levels, collapsed, selected, includeMode, renderSelectButtons, renderSearchBar){
    let $base = $("#" + id)

    if (label){
        $base.append("<h4>" + label + "</h4>")
    }
    if (renderSelectButtons === true){
        $base.append((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.generateSelectButtons)(id, levels.length > 1, includeMode))
    }

    $base.data("includeMode", includeMode)


    let tree = parseTree(choices, levels)

    let $nodeContainer = $("<div>", {"class": _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxNodeHolder + " overflow-auto align-self-center"})
    $base.append($nodeContainer)

    // Render and append the nodes
    appendNodes($nodeContainer.get(0), tree, includeMode)



    // Hide the nodes
    if (levels.length > 1){
        collapseNodes(id, collapsed)

    }


    // Check which nodes should be selected
    preSelectNodes(id, selected, includeMode)


    $(document).on("shiny:connected", function() {
        registerEvents(id)
    });

}

/**
 * It takes an element and an animation type, and toggles the visibility of the element's siblings
 * @param element - the element that is clicked to hide/show
 * @param animation - "toggle" or "slide"
 */
function hideListElement(element, animation="toggle"){
    const animations = {"toggle": {"show": "show", "hide": "hide"}, "slide": {"show": "slideDown", "hide": "slideUp"}}

    let caret = $(element)
    if (!(animation in animations)){
        throw new Error("The animation type is not supported.")

    }

    if (caret.text() === "▼") {
        caret.text("▶")
        caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList)[animations[animation]["hide"]]()
    } else {
        caret.text("▼")
        caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList)[animations[animation]["show"]]()
    }
}



/**
 * It takes the id of a checkboxGroupInput, finds all the checkboxes that are checked, and then sets
 * the Shiny input to the values of the checked checkboxes
 * @param id - The id of the checkboxGroupInput
 */
function setInput(id){

    // Get includeMode from data
    let includeMode = $("#" + id).data("includeMode")

    let selectedValues
    if (includeMode === true){
        selectedValues = getInputIncluded(id)

    } else {
        selectedValues = getInputRegular(id)
    }

    Shiny.setInputValue(id, selectedValues, {priority: "event"});

}

function getInputRegular(id){
    let $base = $("#" + id)
    let selected = []

    $base.find("input:checkbox:checked").each(function(){
        let checkbox = $(this)

        // Check if the checkbox has children as we only need attribute names
        if (checkbox.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList).length === 0){
            selected.push(checkbox.val())
        }
    })

    return selected

}

function getInputIncluded(id){
    let $buttons = $("#" + id).find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude)

    let selected = {"included": [], "excluded": []}
    for (const button of $buttons) {
        let $button = $(button)
        if ($button.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList).length === 0){
            let state = $button.data("state")
            if (state === "include"){
                selected["included"].push($button.val())
            }
            else if (state === "exclude"){
                selected["excluded"].push($button.val())
            }

        }
    }
    return selected
}


function registerIncludeModeEvents(id) {
    let $base = $("#" + id)
    $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude).on("click", function(){
        setInput(id)
    })
}

function registerRegularModeEvents(id) {
    let $base = $("#" + id)
    $base.find(".grouped-checkbox-input").on("click",function(){
        // Select all children and change prop checked
        let $element = $(this)
        $element.siblings("ul").children().find(".grouped-checkbox-input").prop("checked", $element.is(":checked"))

        // If not all children have the same check value, set parent to indeterminate.
        let checkStatus = [$element.is(":checked")]
        $element.parent().parent().siblings().children().children("input[type='checkbox']").each(function(){
            checkStatus.push($(this).is(":checked"))
        })


        let uniqueValues = [... new Set(checkStatus)]

        // Get parent checkbox which inderterminate needs too change. And set indeterminate
        let $parentCheckbox = $element.parent().parent().parent().siblings(".grouped-checkbox-input")
        if (uniqueValues.length > 1){
            $parentCheckbox.prop({indeterminate: true, checked: false})
        } else {
            $parentCheckbox.prop({indeterminate: false, checked: $element.is(":checked")})
        }
        setInput(id)
    })

}

/* Registering events for the checkboxes. */
function registerEvents(id){
    let $base = $("#" + id)

    // Hide if caret is clicked
    $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxCaret).on("click", function (){
        hideListElement(this, "toggle")
    })

    let includeMode = $base.data("includeMode")

    if (includeMode === true){
        registerIncludeModeEvents(id)
    } else {
        registerRegularModeEvents(id)
    }
    // if parent group checkbox get changed, so will children


    // Select all button
    $base.find(".grouped-checkbox-select-all").on("click", function(){
        $base.find(".grouped-checkbox-input").prop({indeterminate: false, checked: true})
        setInput(id)

    })

    // Deselect all
    $base.find(".grouped-checkbox-deselect-all").on("click", function(){
        if (includeMode === true){
            // If include mode, deselect all buttons
            $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude).each(function(){
                (0,_multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__.setStateOfButton)($(this), "unchecked")
            })
        } else {
            $base.find(".grouped-checkbox-input").prop({indeterminate: false, checked: false})
        }
        setInput(id)
    })

    // Expand all button
    $base.find(".grouped-checkbox-expand-all").on("click", function(){
        $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxCaret).each(function(){
            let $caret = $(this)
            if ($caret.text() === "▶") {
                $caret.text("▼")
                $caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList).show()
                $caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList).show()
            }
        })
    })
    

    // Collapse all button
    $base.find(".grouped-checkbox-collapse-all").on("click", function(){
        $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxCaret).each(function(){
            let $caret = $(this)
            if ($caret.text() === "▼") {
                $caret.text("▶")
                $caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList).hide()
                $caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList).hide()
            }
        })
    })

    // Include all
    $base.find(".grouped-checkbox-include-all").on("click", function(){
        // find all buttons and set them to include
        $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude).each(function(){
            ;(0,_multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__.setStateOfButton)($(this), "include")
        })
        setInput(id)
    })

    // Exclude all
    $base.find(".grouped-checkbox-exclude-all").on("click", function() {
        // find all buttons and set them to include
        $base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude).each(function () {
            ;(0,_multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__.setStateOfButton)($(this), "exclude")
        })
        setInput(id)
    })

    // If label is clicked, check the checkbox and its children checkboxes
    $base.find("." + "form-check-label").on("click", function(){
        if ($base.data("includeMode") === true){
            $(this).siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].btnInclude).trigger("click")
        } else {
            $(this).siblings(".grouped-checkbox-input").trigger("click")
        }
    })

    //Set input
    setInput(id)
}




/**
 * > The function `parseTree` takes two arguments, `choices` and `levels`, and returns a new instance
 * of the `ConstructTree` class
 * @param choices - an Object with the data that will be used.
 * @param levels - the number of levels in the tree
 * @returns A ConstructTree object
 */
function parseTree(choices, levels){
    return new _constructTree__WEBPACK_IMPORTED_MODULE_1__.ConstructTree(choices, levels)
}

/**
 * > This function takes a tree Object and appends the nodes to the DOM
 * @param parent - the parent element to append the nodes to
 * @param tree - the tree object
 * @param includeMode
 */
function appendNodes(parent, tree, includeMode) {
    let base = $(parent)
    base.append($("<ul>", {"class": _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList, "id": "grouped-checkbox-list-base"}))


    let queue = []
    queue.push(tree.root)
    while (queue.length > 0) {
        let size = queue.length
        let current

        for (let i = 0; i < size; i++) {
            current = queue.shift()

            for (let child of current.children) {
                queue.push(child)
                if (child.parent.value === "root") {
                    child.htmlID = constructNode(child.value, null, child.has_children, base, includeMode)

                }
                else {
                    child.htmlID = constructNode(child.value, child.parent, child.has_children, base, includeMode)
                }

            }
        }
    }
}

/**
 * It creates a new node, assigns it an ID, and appends it to the parent node
 * @param nodeName - The name of the node
 * @param nodeParent - The parent node of the node you're creating.
 * @param hasChildren - boolean
 * @param base
 * @param include
 * @returns The ID of the node that was just created.
 */
function constructNode(nodeName, nodeParent, hasChildren, base, include){
    // this function uses plain JS which increases the speed it takes to render the nodes by four times in comparison
    // with the more readable jquery    

    let parent;
    if (!nodeParent){
        parent = base.children($("." + _tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList))[0]
    } else {
        parent = base.find("#checkbox-list-" + nodeParent.htmlID)[0]
    }

    // Create ID for the nodes
    let nNodes = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.generateID)()
    let newNodeID = "node-" + nNodes

    let nodeListElement = document.createElement("li")


    // Create node and assign classes
    let node = document.createElement("span")
    node.classList.add("GroupedCheckBox-node", "text-fg")
    node.id = newNodeID


    if (hasChildren){
        node.appendChild((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.createCaret)())
    } 



    // Check if 'include' is true or false
    if (include === true){
        node.appendChild((0,_multiStateCheckbox__WEBPACK_IMPORTED_MODULE_3__.generateMultiStateCheckbox)(nodeName,"include"))
    } else {
        node.appendChild((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.createInputCheckbox)(nodeName, nNodes))
    }
    node.appendChild((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.createCheckboxLabel)(nodeName, nNodes))
        

    if (hasChildren){
        let newList = document.createElement("ul")
        newList.classList.add(_tree_css__WEBPACK_IMPORTED_MODULE_4__["default"].groupedCheckboxList)
        newList.id = "checkbox-list-" + newNodeID
        node.appendChild(newList)
    }

    nodeListElement.appendChild(node)
    parent.appendChild(nodeListElement)

    return newNodeID
}



/***/ }),

/***/ "widgets":
/*!******************************!*\
  !*** external "HTMLWidgets" ***!
  \******************************/
/***/ ((module) => {

module.exports = HTMLWidgets;

/***/ }),

/***/ "shiny":
/*!************************!*\
  !*** external "Shiny" ***!
  \************************/
/***/ ((module) => {

module.exports = Shiny;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***************************************!*\
  !*** ./srcjs/widgets/treecheckbox.js ***!
  \***************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! widgets */ "widgets");
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shiny */ "shiny");
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(shiny__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _modules_renderTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/renderTree.js */ "./srcjs/modules/renderTree.js");





HTMLWidgets.widget({

  name: 'treecheckbox',

  type: 'output',

  factory: function(el, width, height) {

    // TODO: define shared variables for this instance

    return {

      renderValue: function(x) {
        (0,_modules_renderTree_js__WEBPACK_IMPORTED_MODULE_2__.createTree)(el.id, x.label, x.choices, x.levels, x.collapsed, x.selected, x.includeMode, x.select_buttons, x.search_bar)

        // HTMLWidgets.widget sets a default size. Remove this default size and make auto.
        $("#" + el.id).css("height", "auto").css("width", "auto")
      },

      resize: function(width, height) {

        // TODO: code to re-render the widget with a new size

      }

    };
  }
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BOzs7Ozs7Ozs7Ozs7Ozs7O0FDQWlCO0FBQ0Y7O0FBRXFDOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsa0VBQVU7O0FBRWxCO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9zcmNqcy9tb2R1bGVzL3RyZWUuY3NzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vc3JjanMvbW9kdWxlcy90cmVlLmNzcz85Y2IzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9zcmNqcy9tb2R1bGVzL2NvbnN0cnVjdFRyZWUuanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9zcmNqcy9tb2R1bGVzL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9zcmNqcy9tb2R1bGVzL211bHRpU3RhdGVDaGVja2JveC5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL3NyY2pzL21vZHVsZXMvcmVuZGVyVHJlZS5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC9leHRlcm5hbCB2YXIgXCJIVE1MV2lkZ2V0c1wiIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94L2V4dGVybmFsIHZhciBcIlNoaW55XCIiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9zcmNqcy93aWRnZXRzL3RyZWVjaGVja2JveC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIFN0eWxlIHRoZSBjYXJldC9hcnJvdyAqL1xcbi5VTndreGV1OEphTFVSN3pzTE9MYyB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgLyogUHJldmVudCB0ZXh0IHNlbGVjdGlvbiAqL1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luLXJpZ2h0OiA2cHg7XFxufVxcblxcbi5kcEc5VkpDYkUxVDNodk5xV0FYUSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cXG4uZlJEcG1KSjlNUlhhbkVSZGxndVAge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICBib3JkZXItcmFkaXVzOiA4cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjY2NjY2NjO1xcbiAgbWF4LWhlaWdodDogMjV2aDtcXG59XFxuXFxuLkdtdEVNdUUxQmhCdU9LNFVEZW9KIHtcXG4gIG1hcmdpbjogMDtcXG4gIGJvcmRlcjogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgbWF4LWhlaWdodDogMThweDtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgcGFkZGluZzogMCAycHggMCAwO1xcbn1cXG5cXG4uR210RU11RTFCaEJ1T0s0VURlb0o6aG92ZXIge1xcbiAgd2lkdGg6IGZpdC1jb250ZW50O1xcbiAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG4gIG1pbi13aWR0aDogMTZweDtcXG4gIG1pbi1oZWlnaHQ6IDE2cHg7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG5cXG4ucGE1X2s4U0tTZ1JmV0xUTWZJZkgge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcXG4gIGJvcmRlci1sZWZ0OiAwO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDAgM3B4IDNweCAwO1xcbn1cXG5cXG4ucUlQVnROb2RfaVFYcVBSNWdJdHcge1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYm9yZGVyLWNvbG9yOiBvcmFuZ2U7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAxLjE3cHg7XFxuICBjb2xvcjogb3JhbmdlO1xcbn1cXG5cXG4ucUlQVnROb2RfaVFYcVBSNWdJdHc6aG92ZXIge1xcbiAgd2lkdGg6IDE2cHg7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICBwYWRkaW5nOiAxcHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3JkZXItY29sb3I6IG9yYW5nZTtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItd2lkdGg6IDEuMTdweDtcXG4gIGNvbG9yOiBvcmFuZ2U7XFxufVxcblxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPXRyZWUuY3NzLm1hcCAqL1xcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyY2pzL21vZHVsZXMvdHJlZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmNqcy9tb2R1bGVzL3RyZWUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNBLDBCQUFBO0FBQ0E7RUFDRSxlQUFBO0VBQ0EsaUJBQUEsRUFBQSwyQkFBQTtFQUNBLHFCQUFBO0VBQ0EsaUJBQUE7QUNBRjs7QURHQTtFQUNFLGdCQUFBO0FDQUY7O0FER0E7RUFDRSx1QkFBQTtFQUNBLGtCQUFBO0VBQ0EseUJBQUE7RUFDQSxnQkFBQTtBQ0FGOztBRElBO0VBQ0ksU0FBQTtFQUNBLFNBQUE7RUFDQSw2QkFBQTtFQUNBLGdCQUFBO0VBQ0Esb0JBQUE7RUFDQSxzQkFBQTtFQUNBLGlCQUFBO0VBQ0Esa0JBQUE7QUNESjs7QURJQTtFQUNFLGtCQUFBO0VBQ0EsbUJBQUE7RUFDQSxlQUFBO0VBQ0EsZ0JBQUE7RUFDQSxhQUFBO0FDREY7O0FESUE7RUFDSSx5QkFBQTtFQUNBLGNBQUE7RUFDQSxhQUFBO0VBQ0EsMEJBQUE7QUNESjs7QURNQTtFQUNFLGtCQUFBO0VBQ0Esb0JBQUE7RUFDQSxtQkFBQTtFQUNBLG9CQUFBO0VBQ0EsYUFBQTtBQ0hGOztBRE1BO0VBQ0UsV0FBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7RUFDQSxvQkFBQTtFQUNBLG1CQUFBO0VBQ0Esb0JBQUE7RUFDQSxhQUFBO0FDSEY7O0FBRUEsbUNBQW1DXCIsXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmxvY2FscyA9IHtcblx0XCJncm91cGVkQ2hlY2tib3hDYXJldFwiOiBcIlVOd2t4ZXU4SmFMVVI3enNMT0xjXCIsXG5cdFwiZ3JvdXBlZENoZWNrYm94TGlzdFwiOiBcImRwRzlWSkNiRTFUM2h2TnFXQVhRXCIsXG5cdFwiZ3JvdXBlZENoZWNrYm94Tm9kZUhvbGRlclwiOiBcImZSRHBtSko5TVJYYW5FUmRsZ3VQXCIsXG5cdFwiYnRuSW5jbHVkZVwiOiBcIkdtdEVNdUUxQmhCdU9LNFVEZW9KXCIsXG5cdFwiYnRuSGVscExhYmVsXCI6IFwicGE1X2s4U0tTZ1JmV0xUTWZJZkhcIixcblx0XCJidG5JbmRldGVybWluYXRlXCI6IFwicUlQVnROb2RfaVFYcVBSNWdJdHdcIlxufTtcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1swXS51c2VbMV0hLi90cmVlLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzBdLnVzZVsxXSEuL3RyZWUuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcblxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG5cbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIlxuXG4vKiBUaGUgQ29uc3RydWN0VHJlZSBjbGFzcyB0YWtlcyBpbiBhIGxpc3Qgb2YgcmVjb3JkcyBhbmQgYSBsaXN0IG9mIGxldmVscywgYW5kIGJ1aWxkcyBhIHRyZWUgb2Ygbm9kZXNcbndoZXJlIGVhY2ggbm9kZSByZXByZXNlbnRzIGEgbGV2ZWwgYW5kIGVhY2ggbm9kZSdzIGNoaWxkcmVuIHJlcHJlc2VudCB0aGUgbmV4dCBsZXZlbCAqL1xuY2xhc3MgQ29uc3RydWN0VHJlZSB7XG4gICAgcm9vdFxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGxldmVscykge1xuICAgICAgICB0aGlzLmJ1aWxkVHJlZShkYXRhLCBsZXZlbHMpXG4gICAgfVxuXG5cbi8qKlxuICogPiBUaGUgZnVuY3Rpb24gdGFrZXMgaW4gYSBkYXRhIHNldCBhbmQgYSBsaXN0IG9mIGxldmVscywgYW5kIGJ1aWxkcyBhIHRyZWUgd2l0aCB0aGUgZGF0YSBzZXRcbiAqIEBwYXJhbSBkYXRhIC0gdGhlIGRhdGEgeW91IHdhbnQgdG8gYnVpbGQgdGhlIHRyZWUgZnJvbVxuICogQHBhcmFtIGxldmVscyAtIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgdGhlIGxldmVscyBvZiB0aGUgdHJlZS5cbiAqL1xuICAgIGJ1aWxkVHJlZShkYXRhLCBsZXZlbHMpe1xuICAgICAgICBsZXQgcm9vdCA9IG5ldyBOb2RlKFwicm9vdFwiKVxuICAgICAgICBsZXQgbmV3RGF0YVxuXG4gICAgICAgIGRhdGEuZm9yRWFjaChyZWNvcmQgPT4ge1xuICAgICAgICAgICAgbmV3RGF0YSA9IFtdXG4gICAgICAgICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YS5wdXNoKHJlY29yZFtsZXZlbF0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy4jZmluZE9yQXBwZW5kKHJvb3QsIG5ld0RhdGEpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICB9XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4IGRlcHRoIG9mIHRoZSB0cmVlXG4gKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIHRyZWVcbiAqL1xuICAgIGZpbmRNYXhEZXB0aCgpe1xuICAgICAgICBsZXQgcXVldWUgPSBbXVxuICAgICAgICBsZXQgZGVwdGggPSAwXG5cbiAgICAgICAgcXVldWUucHVzaCh0aGlzLnJvb3QpXG5cbiAgICAgICAgd2hpbGUocXVldWUubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHF1ZXVlLmxlbmd0aFxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemUgOyBpKyspe1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjdXJyZW50LmNoaWxkcmVuKXtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChjaGlsZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXB0aCArK1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aCAtIDFcbiAgICB9XG5cbi8qKlxuICogPiBHaXZlbiBhIHRyZWUgYW5kIGEgbGlzdCBvZiB2YWx1ZXMsIGZpbmQgdGhlIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYXRjaGVzIHRoZSBsYXN0IHZhbHVlIGluIHRoZVxuICogbGlzdCwgYW5kIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICogQHBhcmFtIHRyZWUgLSB0aGUgdHJlZSB0byBzZWFyY2hcbiAqIEBwYXJhbSB2YWx1ZXMgLSBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHRyZWVcbiAqIEByZXR1cm5zIFRoZSB0cmVlIHdpdGggdGhlIG5ldyB2YWx1ZXMgYWRkZWQuXG4gKi9cbiAgICAjZmluZE9yQXBwZW5kKHRyZWUsIHZhbHVlcyl7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aCA7IGkrKyl7XG4gICAgICAgICAgICBsZXQga2V5UXVldWUgPSB2YWx1ZXMuc2xpY2UoMCwgaSArIDEpXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV1cbiAgICAgICAgICAgIGxldCBbbm9kZUluLCBfXSA9IHRoaXMuI3JlY3Vyc2l2ZVNlYXJjaCh0cmVlLCBrZXlRdWV1ZSlcbiAgICAgICAgICAgIGlmIChub2RlSW4udmFsdWUgIT09IHZhbHVlKXtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Tm9kZSA9IG5ldyBOb2RlKHZhbHVlKVxuICAgICAgICAgICAgICAgIG5vZGVJbi5hZGRfY2hpbGQobmV3Tm9kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4odHJlZSlcbiAgICB9XG4gICAgXG4vKipcbiAqID4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSBhbmQgYSBsaXN0IG9mIHZhbHVlcyB0byBmaW5kLiBJdCByZXR1cm5zIHRoZSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgbGFzdFxuICogdmFsdWUgaW4gdGhlIGxpc3QsIGFuZCB0aGUgbGlzdCBvZiB2YWx1ZXMgdGhhdCB3ZXJlIG5vdCBmb3VuZFxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHkgc2VhcmNoaW5nXG4gKiBAcGFyYW0gZmluZCAtIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgdGhlIHBhdGggdG8gdGhlIG5vZGUgeW91IHdhbnQgdG8gZmluZFxuICogQHJldHVybnMgVGhlIG5vZGUgdGhhdCBpcyB0aGUgbGFzdCBpbiB0aGUgcGF0aCwgYW5kIHRoZSBwYXRoIHRoYXQgaXMgbGVmdCB0byBiZSBzZWFyY2hlZC5cbiAqL1xuICAgICNyZWN1cnNpdmVTZWFyY2gobm9kZSwgZmluZCl7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5cbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGZpbmRpbmcgPSBmaW5kWzBdXG4gICAgICAgICAgICBpZiAoZmluZGluZyA9PT0gY2hpbGQudmFsdWUpe1xuICAgICAgICAgICAgICAgIGZpbmQuc2hpZnQoKVxuICAgICAgICAgICAgICAgIGlmIChmaW5kLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVjdXJzaXZlU2VhcmNoKGNoaWxkLCBmaW5kKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybihbY2hpbGQsIGZpbmRdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vZGUsIGZpbmRdXG4gICAgfVxuXG5cbn1cblxuXG4vKiBBIG5vZGUgaXMgYSB2YWx1ZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgYSBwYXJlbnQgKi9cbmNsYXNzIE5vZGV7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbil7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFxuICAgICAgICB0aGlzLmRlcHRoID0gMFxuICAgIH1cblxuICAgIC8qXG4gICAgICogQWRkIGNoaWxkcmVuIHRvIG5vZGUsIGFuZCByZWdpc3RlciBwYXJlbnQgaW4gY2hpbGQuXG4gICAgICovXG4gICAgYWRkX2NoaWxkKGNoaWxkKXtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgY2hpbGQuYWRkUGFyZW50KHRoaXMpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkUGFyZW50KHBhcmVudCl7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQuZGVwdGggKyAxXG4gICAgfVxuXG4gICAgZ2V0IGhhc19jaGlsZHJlbigpe1xuICAgICAgICByZXR1cm4oKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkpXG4gICAgfVxuXG4gICAgZ2V0IHNpYmxpbmdzKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlblxuICAgIH1cblxuICAgIGZpbmRPYmplY3RCeU5hbWUobmFtZSl7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBuYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGNoaWxkLmZpbmRPYmplY3RCeU5hbWUobmFtZSlcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IHtDb25zdHJ1Y3RUcmVlfSIsImltcG9ydCBzdHlsZXMgZnJvbSAnLi90cmVlLmNzcydcblxuLyogQSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gKi9cbmxldCBnZW5lcmF0ZUlEID0gKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG4gKz0gMVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG59KC0xKSlcblxuXG4vKipcbiAqIEl0IGNyZWF0ZXMgYSBzcGFuIGVsZW1lbnQsIGFkZHMgdGhlIGNsYXNzIGBncm91cGVkQ2hlY2tib3hDYXJldGAgdG8gaXQsIGFuZCBzZXRzIGl0cyBpbm5lciB0ZXh0IHRvXG4gKiBcIuKWvFwiLlxuICogQHJldHVybnMgQSBzcGFuIGVsZW1lbnQgd2l0aCB0aGUgY2xhc3MgXCJncm91cGVkQ2hlY2tib3hDYXJldFwiIGFuZCB0aGUgaW5uZXIgdGV4dCBcIuKWvFwiXG4gKi9cbiBmdW5jdGlvbiBjcmVhdGVDYXJldCgpe1xuICAgIGxldCBjYXJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgY2FyZXQuY2xhc3NMaXN0LmFkZChzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpXG4gICAgY2FyZXQuaW5uZXJUZXh0ID0gXCLilrxcIlxuICAgIHJldHVybihjYXJldClcbn1cblxuXG4vKipcbiAqIEl0IGNyZWF0ZXMgYSBjaGVja2JveCBpbnB1dCBlbGVtZW50XG4gKiBAcGFyYW0gbm9kZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbm9kZVxuICogQHBhcmFtIG5vZGVJRCAtIFRoZSBJRCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dENoZWNrYm94IGVsZW1lbnRcbiAqL1xuIGZ1bmN0aW9uIGNyZWF0ZUlucHV0Q2hlY2tib3gobm9kZU5hbWUsIG5vZGVJRCkge1xuICAgIGxldCBpbnB1dENoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpXG4gICAgaW5wdXRDaGVja2JveC5jbGFzc0xpc3QuYWRkKFwiZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiLCBcImZvcm0tY2hlY2staW5wdXRcIilcbiAgICBpbnB1dENoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCJcbiAgICBpbnB1dENoZWNrYm94LnZhbHVlID0gbm9kZU5hbWVcbiAgICBpbnB1dENoZWNrYm94LmlkID0gXCJub2RlLWlucHV0LWNoZWNrXCIgKyBub2RlSURcbiAgICByZXR1cm4oaW5wdXRDaGVja2JveClcbn1cblxuLyoqXG4gKiBJdCBjcmVhdGVzIGEgbGFiZWwgZm9yIGEgY2hlY2tib3hcbiAqIEBwYXJhbSBub2RlTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gaWQgLSB0aGUgaWQgb2YgdGhlIG5vZGVcbiAqIEByZXR1cm5zIEEgbGFiZWwgZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGVja2JveExhYmVsKG5vZGVOYW1lLCBpZCl7XG4gICAgbGV0IGxhYmVsQ2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIilcbiAgICBsYWJlbENoZWNrYm94LmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNoZWNrLWxhYmVsXCIpXG4gICAgbGFiZWxDaGVja2JveC5mb3IgPSBcIm5vZGUtaW5wdXQtY2hlY2tcIiArIGlkXG4gICAgbGFiZWxDaGVja2JveC5pbm5lckhUTUwgPSBub2RlTmFtZVxuICAgIHJldHVybihsYWJlbENoZWNrYm94KVxufVxuXG4vKipcbiAqIEl0IGdlbmVyYXRlcyBhIGNvbnRhaW5lciB3aXRoIHR3byBidXR0b25zLCBvbmUgdG8gc2VsZWN0IGFsbCBjaGVja2JveGVzIGFuZCBvbmUgdG8gZGVzZWxlY3QgYWxsXG4gKiBjaGVja2JveGVzXG4gKiBAcmV0dXJucyBBIGRpdiB3aXRoIHR3byBidXR0b25zLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdEJ1dHRvbnMoaWQsIGlzSGllcmFyY2hpY2FsLCBpbmNsdWRlTW9kZSl7XG5cbiAgICBsZXQgJGNvbnRhaW5lciA9ICQoXCI8ZGl2PlwiLCB7XCJjbGFzc1wiOiBcImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtZXZlbmx5XCJ9KVxuXG4gICAgbGV0IGdlbmVyYXRlZElEID0gZ2VuZXJhdGVJRCgpXG5cbiAgICBsZXQgJGRyb3Bkb3duID0gJChcIjxkaXY+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd25cIn0pXG5cbiAgICBpZiAoaW5jbHVkZU1vZGUgPT09IHRydWUpe1xuICAgICAgICBsZXQgJGRyb3BEb3duU2VsZWN0QnV0dG9uID0gJChcIjxidXR0b24+XCIsIHtcImNsYXNzXCI6IFwiYnRuIGJ0bi1vdXRsaW5lLWZnIGRyb3Bkb3duLXRvZ2dsZSBcIiwgXCJ0eXBlXCI6IFwiYnV0dG9uXCIsIFwiaWRcIjogXCJkcm9wRG93blNlbGVjdC1cIiArIGdlbmVyYXRlZElEfSlcbiAgICAgICAgICAgIC50ZXh0KFwiKGRlKXNlbGVjdCBhbGxcIilcbiAgICAgICAgICAgIC5hdHRyKFwiZGF0YS1icy10b2dnbGVcIiwgXCJkcm9wZG93blwiKVxuICAgICAgICAgICAgLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcbiAgICAgICAgJGRyb3Bkb3duLmFwcGVuZCgkZHJvcERvd25TZWxlY3RCdXR0b24pXG5cbiAgICAgICAgLy8gQ3JlYXRlIGRyb3Bkb3duIG1lbnUgZm9yIHRoZSBkcm9wZG93blNlbGVjdCBidXR0b25cbiAgICAgICAgbGV0IGRyb3BEb3duU2VsZWN0TWVudSA9ICQoXCI8dWw+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24tbWVudVwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcImRyb3BEb3duU2VsZWN0LVwiICsgZ2VuZXJhdGVkSUR9KVxuICAgICAgICBkcm9wRG93blNlbGVjdE1lbnUuYXBwZW5kKCQoXCI8bGk+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24taXRlbVwifSkuYXBwZW5kKCQoXCI8YT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1saW5rIGdyb3VwZWQtY2hlY2tib3gtaW5jbHVkZS1hbGxcIn0pLnRleHQoXCJJbmNsdWRlIGFsbFwiKSkpXG4gICAgICAgIGRyb3BEb3duU2VsZWN0TWVudS5hcHBlbmQoJChcIjxsaT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1pdGVtXCJ9KS5hcHBlbmQoJChcIjxhPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWxpbmsgZ3JvdXBlZC1jaGVja2JveC1leGNsdWRlLWFsbFwifSkudGV4dChcIkV4Y2x1ZGUgYWxsXCIpKSlcbiAgICAgICAgZHJvcERvd25TZWxlY3RNZW51LmFwcGVuZCgkKFwiPGxpPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWl0ZW1cIn0pLmFwcGVuZCgkKFwiPGE+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24tbGluayBncm91cGVkLWNoZWNrYm94LWRlc2VsZWN0LWFsbFwifSkudGV4dChcIkRlc2VsZWN0IGFsbFwiKSkpXG5cbiAgICAgICAgJGRyb3Bkb3duLmFwcGVuZChkcm9wRG93blNlbGVjdE1lbnUpXG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKCRkcm9wZG93bilcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmVuZGVyIHRoZSAoZGUpc2VsZWN0IGFsbCBidXR0b25zIGhlcmUuXG4gICAgICAgIGxldCBkcm9wRG93blNlbGVjdEJ1dHRvbiA9ICQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImJ0biBidG4tb3V0bGluZS1mZyBkcm9wZG93bi10b2dnbGUgXCIsIFwidHlwZVwiOiBcImJ1dHRvblwiLCBcImlkXCI6IFwiZHJvcERvd25TZWxlY3QtXCIgKyBnZW5lcmF0ZWRJRH0pXG4gICAgICAgICAgICAudGV4dChcIihkZSlzZWxlY3QgYWxsXCIpXG4gICAgICAgICAgICAuYXR0cihcImRhdGEtYnMtdG9nZ2xlXCIsIFwiZHJvcGRvd25cIilcbiAgICAgICAgICAgIC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG4gICAgICAgICRkcm9wZG93bi5hcHBlbmQoZHJvcERvd25TZWxlY3RCdXR0b24pXG5cbiAgICAgICAgLy8gQ3JlYXRlIGRyb3Bkb3duIG1lbnUgZm9yIHRoZSBkcm9wZG93blNlbGVjdCBidXR0b25cbiAgICAgICAgbGV0IGRyb3BEb3duU2VsZWN0TWVudSA9ICQoXCI8dWw+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24tbWVudVwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBcImRyb3BEb3duU2VsZWN0LVwiICsgZ2VuZXJhdGVkSUR9KVxuICAgICAgICBkcm9wRG93blNlbGVjdE1lbnUuYXBwZW5kKCQoXCI8bGk+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24taXRlbVwifSkuYXBwZW5kKCQoXCI8YT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1saW5rIGdyb3VwZWQtY2hlY2tib3gtc2VsZWN0LWFsbFwifSkudGV4dChcIlNlbGVjdCBhbGxcIikpKVxuICAgICAgICBkcm9wRG93blNlbGVjdE1lbnUuYXBwZW5kKCQoXCI8bGk+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24taXRlbVwifSkuYXBwZW5kKCQoXCI8YT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1saW5rIGdyb3VwZWQtY2hlY2tib3gtZGVzZWxlY3QtYWxsXCJ9KS50ZXh0KFwiRGVzZWxlY3QgYWxsXCIpKSlcblxuICAgICAgICAkZHJvcGRvd24uYXBwZW5kKGRyb3BEb3duU2VsZWN0TWVudSlcbiAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoJGRyb3Bkb3duKVxuICAgIH1cblxuICAgIGlmIChpc0hpZXJhcmNoaWNhbCA9PT0gdHJ1ZSl7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBjb2xsYXBzZSBtZW51XG4gICAgICAgICAgICAkZHJvcGRvd24gPSAkKFwiPGRpdj5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93blwifSlcbiAgICAgICAgICAgIGxldCAkZHJvcERvd25Db2xsYXBzZUJ1dHRvbiA9ICQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImJ0biBidG4tb3V0bGluZS1mZyBkcm9wZG93bi10b2dnbGUgXCIsIFwidHlwZVwiOiBcImJ1dHRvblwiLCBcImlkXCI6IFwiZHJvcERvd25Db2xsYXBzZS1cIiArIGdlbmVyYXRlZElEfSlcbiAgICAgICAgICAgICAgICAudGV4dChcImNvbGxhcHNlXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWJzLXRvZ2dsZVwiLCBcImRyb3Bkb3duXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcbiAgICAgICAgICAgICRkcm9wZG93bi5hcHBlbmQoJGRyb3BEb3duQ29sbGFwc2VCdXR0b24pXG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBkcm9wZG93biBtZW51IGZvciB0aGUgZHJvcGRvd25Db2xsYXBzZSBidXR0b25cbiAgICAgICAgICAgIGxldCAkZHJvcERvd25Db2xsYXBzZU1lbnUgPSAkKFwiPHVsPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLW1lbnVcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJkcm9wRG93bkNvbGxhcHNlLVwiICsgZ2VuZXJhdGVkSUR9KVxuICAgICAgICAgICAgJGRyb3BEb3duQ29sbGFwc2VNZW51LmFwcGVuZCgkKFwiPGxpPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWl0ZW1cIn0pLmFwcGVuZCgkKFwiPGE+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24tbGluayBncm91cGVkLWNoZWNrYm94LWNvbGxhcHNlLWFsbFwifSkudGV4dChcIkNvbGxhcHNlIGFsbFwiKSkpXG4gICAgICAgICAgICAkZHJvcERvd25Db2xsYXBzZU1lbnUuYXBwZW5kKCQoXCI8bGk+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24taXRlbVwifSkuYXBwZW5kKCQoXCI8YT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1saW5rIGdyb3VwZWQtY2hlY2tib3gtZXhwYW5kLWFsbFwifSkudGV4dChcIkV4cGFuZCBhbGxcIikpKVxuICAgICAgICAgICAgJGRyb3Bkb3duLmFwcGVuZCgkZHJvcERvd25Db2xsYXBzZU1lbnUpXG4gICAgICAgICAgICAkY29udGFpbmVyLmFwcGVuZCgkZHJvcGRvd24pXG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyAvLyBnZXQgbW9kZVxuICAgIC8vXG4gICAgLy8gaWYgKHJlbmRlckluY2x1ZGVkKXtcbiAgICAvLyAgICAgLy8gR2VuZXJhdGUgY29sbGFwc2UgbWVudVxuICAgIC8vICAgICBkcm9wZG93biA9ICQoXCI8ZGl2PlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duXCJ9KVxuICAgIC8vICAgICBsZXQgZHJvcERvd25Db2xsYXBzZUJ1dHRvbiA9ICQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImJ0biBidG4tb3V0bGluZS1mZyBkcm9wZG93bi10b2dnbGUgXCIsIFwidHlwZVwiOiBcImJ1dHRvblwiLCBcImlkXCI6IFwiZHJvcERvd25Db2xsYXBzZS1cIiArIGdlbmVyYXRlZElEfSlcbiAgICAvLyAgICAgICAgIC50ZXh0KFwiY29sbGFwc2VcIilcbiAgICAvLyAgICAgICAgIC5hdHRyKFwiZGF0YS1icy10b2dnbGVcIiwgXCJkcm9wZG93blwiKVxuICAgIC8vICAgICAgICAgLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIilcbiAgICAvLyAgICAgZHJvcGRvd24uYXBwZW5kKGRyb3BEb3duQ29sbGFwc2VCdXR0b24pXG4gICAgLy9cbiAgICAvLyAgICAgLy8gQ3JlYXRlIGRyb3Bkb3duIG1lbnUgZm9yIHRoZSBkcm9wZG93bkNvbGxhcHNlIGJ1dHRvblxuICAgIC8vICAgICBsZXQgZHJvcERvd25Db2xsYXBzZU1lbnUgPSAkKFwiPHVsPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLW1lbnVcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogXCJkcm9wRG93bkNvbGxhcHNlLVwiICsgZ2VuZXJhdGVkSUR9KVxuICAgIC8vICAgICBkcm9wRG93bkNvbGxhcHNlTWVudS5hcHBlbmQoJChcIjxsaT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1pdGVtXCJ9KS5hcHBlbmQoJChcIjxhPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWxpbmsgZ3JvdXBlZC1jaGVja2JveC1jb2xsYXBzZS1hbGxcIn0pLnRleHQoXCJDb2xsYXBzZSBhbGxcIikpKVxuICAgIC8vICAgICBkcm9wRG93bkNvbGxhcHNlTWVudS5hcHBlbmQoJChcIjxsaT5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1pdGVtXCJ9KS5hcHBlbmQoJChcIjxhPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWxpbmsgZ3JvdXBlZC1jaGVja2JveC1leHBhbmQtYWxsXCJ9KS50ZXh0KFwiRXhwYW5kIGFsbFwiKSkpXG4gICAgLy8gICAgIGRyb3Bkb3duLmFwcGVuZChkcm9wRG93bkNvbGxhcHNlTWVudSlcbiAgICAvLyAgICAgY29udGFpbmVyLmFwcGVuZChkcm9wZG93bilcbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyBpZiAocmVuZGVySW5jbHVkZWQpe1xuICAgIC8vICAgICAvLyBHZW5lcmF0ZSBpbmNsdWRlIG1lbnVcbiAgICAvLyAgICAgZHJvcGRvd24gPSAkKFwiPGRpdj5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93blwifSlcbiAgICAvLyAgICAgbGV0IGRyb3BEb3duSW5jbHVkZUJ1dHRvbiA9ICQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImJ0biBidG4tb3V0bGluZS1mZyBkcm9wZG93bi10b2dnbGUgXCIsIFwidHlwZVwiOiBcImJ1dHRvblwiLCBcImlkXCI6IFwiZHJvcERvd25JbmNsdWRlLVwiICsgZ2VuZXJhdGVkSUR9KVxuICAgIC8vICAgICAgICAgLnRleHQoXCJpbmNsdWRlXCIpXG4gICAgLy8gICAgICAgICAuYXR0cihcImRhdGEtYnMtdG9nZ2xlXCIsIFwiZHJvcGRvd25cIilcbiAgICAvLyAgICAgICAgIC5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpXG4gICAgLy8gICAgIGRyb3Bkb3duLmFwcGVuZChkcm9wRG93bkluY2x1ZGVCdXR0b24pXG4gICAgLy9cbiAgICAvLyAgICAgLy8gQ3JlYXRlIGRyb3Bkb3duIG1lbnUgZm9yIHRoZSBkcm9wZG93bkluY2x1ZGUgYnV0dG9uXG4gICAgLy8gICAgIGxldCBkcm9wRG93bkluY2x1ZGVNZW51ID0gJChcIjx1bD5cIiwge1wiY2xhc3NcIjogXCJkcm9wZG93bi1tZW51XCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwiZHJvcERvd25JbmNsdWRlLVwiICsgZ2VuZXJhdGVkSUR9KVxuICAgIC8vICAgICBkcm9wRG93bkluY2x1ZGVNZW51LmFwcGVuZCgkKFwiPGxpPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWl0ZW1cIn0pLmFwcGVuZCgkKFwiPGE+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24tbGluayBncm91cGVkLWNoZWNrYm94LWluY2x1ZGUtYWxsXCJ9KS50ZXh0KFwiSW5jbHVkZSBhbGxcIikpKVxuICAgIC8vICAgICBkcm9wRG93bkluY2x1ZGVNZW51LmFwcGVuZCgkKFwiPGxpPlwiLCB7XCJjbGFzc1wiOiBcImRyb3Bkb3duLWl0ZW1cIn0pLmFwcGVuZCgkKFwiPGE+XCIsIHtcImNsYXNzXCI6IFwiZHJvcGRvd24tbGluayBncm91cGVkLWNoZWNrYm94LWV4Y2x1ZGUtYWxsXCJ9KS50ZXh0KFwiRXhjbHVkZSBhbGxcIikpKVxuICAgIC8vICAgICBkcm9wZG93bi5hcHBlbmQoZHJvcERvd25JbmNsdWRlTWVudSlcbiAgICAvLyAgICAgY29udGFpbmVyLmFwcGVuZChkcm9wZG93bilcbiAgICAvLyB9XG4gICAgcmV0dXJuKCRjb250YWluZXIpXG59XG5cbmV4cG9ydCB7Y3JlYXRlQ2FyZXQsIGNyZWF0ZUlucHV0Q2hlY2tib3gsIGNyZWF0ZUNoZWNrYm94TGFiZWwsIGdlbmVyYXRlU2VsZWN0QnV0dG9ucywgZ2VuZXJhdGVJRH0iLCJpbXBvcnQgc3R5bGVzIGZyb20gXCIuL3RyZWUuY3NzXCI7XG5cblxuY29uc3QgZGVmYXVsdFN0YXRlcyA9IHtcbiAgICBcInVuY2hlY2tlZFwiOiB7XG4gICAgICAgIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwiYmkgYmktc3F1YXJlXCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPlxcbicgK1xuICAgICAgICAgICAgJyAgPHBhdGggZD1cIk0xNCAxYTEgMSAwIDAgMSAxIDF2MTJhMSAxIDAgMCAxLTEgMUgyYTEgMSAwIDAgMS0xLTFWMmExIDEgMCAwIDEgMS0xaDEyek0yIDBhMiAyIDAgMCAwLTIgMnYxMmEyIDIgMCAwIDAgMiAyaDEyYTIgMiAwIDAgMCAyLTJWMmEyIDIgMCAwIDAtMi0ySDJ6XCIvPlxcbicgK1xuICAgICAgICAgICAgJzwvc3ZnPicsXG4gICAgICAgIFwidGV4dENvbG91clwiOiBcInRleHQtZGFya1wiLFxuICAgICAgICBcInNwYW5DbGFzc2VzXCI6IFwiYmctZGFyayB0ZXh0LXdoaXRlXCIsXG4gICAgICAgIFwidmFsdWVcIjogMFxuICAgIH0sXG4gICAgXCJpbmNsdWRlXCI6IHtcbiAgICAgICAgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJiaSBiaS1jaGVjay1zcXVhcmVcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XFxuJyArXG4gICAgICAgICAgICAnICA8cGF0aCBkPVwiTTE0IDFhMSAxIDAgMCAxIDEgMXYxMmExIDEgMCAwIDEtMSAxSDJhMSAxIDAgMCAxLTEtMVYyYTEgMSAwIDAgMSAxLTFoMTJ6TTIgMGEyIDIgMCAwIDAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlYyYTIgMiAwIDAgMC0yLTJIMnpcIi8+XFxuJyArXG4gICAgICAgICAgICAnICA8cGF0aCBkPVwiTTEwLjk3IDQuOTdhLjc1Ljc1IDAgMCAxIDEuMDcxIDEuMDVsLTMuOTkyIDQuOTlhLjc1Ljc1IDAgMCAxLTEuMDguMDJMNC4zMjQgOC4zODRhLjc1Ljc1IDAgMSAxIDEuMDYtMS4wNmwyLjA5NCAyLjA5MyAzLjQ3My00LjQyNWEuMjM1LjIzNSAwIDAgMSAuMDItLjAyMnpcIi8+XFxuJyArXG4gICAgICAgICAgICAnPC9zdmc+JyxcbiAgICAgICAgXCJ0ZXh0Q29sb3VyXCI6IFwidGV4dC1zdWNjZXNzXCIsXG4gICAgICAgIFwic3BhbkNsYXNzZXNcIjogXCJiZy1zdWNjZXNzIHRleHQtd2hpdGVcIixcbiAgICAgICAgXCJ2YWx1ZVwiOiBcImluY2x1ZGVcIlxuXG4gICAgfSwgXCJleGNsdWRlXCI6IHtcbiAgICAgICAgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJiaSBiaS14LXNxdWFyZVwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj48cGF0aCBkPVwiTTE0IDFhMSAxIDAgMCAxIDEgMXYxMmExIDEgMCAwIDEtMSAxSDJhMSAxIDAgMCAxLTEtMVYyYTEgMSAwIDAgMSAxLTFoMTJ6TTIgMGEyIDIgMCAwIDAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlYyYTIgMiAwIDAgMC0yLTJIMnpcIi8+PHBhdGggZD1cIk00LjY0NiA0LjY0NmEuNS41IDAgMCAxIC43MDggMEw4IDcuMjkzbDIuNjQ2LTIuNjQ3YS41LjUgMCAwIDEgLjcwOC43MDhMOC43MDcgOGwyLjY0NyAyLjY0NmEuNS41IDAgMCAxLS43MDguNzA4TDggOC43MDdsLTIuNjQ2IDIuNjQ3YS41LjUgMCAwIDEtLjcwOC0uNzA4TDcuMjkzIDggNC42NDYgNS4zNTRhLjUuNSAwIDAgMSAwLS43MDh6XCIvPjwvc3ZnPicsXG4gICAgICAgIFwidGV4dENvbG91clwiOiBcInRleHQtZGFuZ2VyXCIsXG4gICAgICAgIFwic3BhbkNsYXNzZXNcIjogXCJiZy1kYW5nZXIgdGV4dC13aGl0ZVwiLFxuICAgICAgICBcInZhbHVlXCI6IFwiZXhjbHVkZVwiXG5cbiAgICB9LFwiaW5kZXRlcm1pbmF0ZVwiOiB7XG4gICAgICAgIFwic3ltYm9sXCI6XG4gICAgICAgICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwiYmkgYmktZGFzaC1zcXVhcmVcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+XFxuJyArXG4gICAgICAgICAgICAnICA8cGF0aCBkPVwiTTE0IDFhMSAxIDAgMCAxIDEgMXYxMmExIDEgMCAwIDEtMSAxSDJhMSAxIDAgMCAxLTEtMVYyYTEgMSAwIDAgMSAxLTFoMTJ6TTIgMGEyIDIgMCAwIDAtMiAydjEyYTIgMiAwIDAgMCAyIDJoMTJhMiAyIDAgMCAwIDItMlYyYTIgMiAwIDAgMC0yLTJIMnpcIi8+XFxuJyArXG4gICAgICAgICAgICAnICA8cGF0aCBkPVwiTTQgOGEuNS41IDAgMCAxIC41LS41aDdhLjUuNSAwIDAgMSAwIDFoLTdBLjUuNSAwIDAgMSA0IDh6XCIvPlxcbicgK1xuICAgICAgICAgICAgJzwvc3ZnPicsXG4gICAgICAgIFwidGV4dENvbG91clwiOiBcInRleHQtd2FybmluZ1wiLFxuICAgICAgICBcInNwYW5DbGFzc2VzXCI6IFwiYmctd2FybmluZyB0ZXh0LXdoaXRlXCIsXG4gICAgICAgIFwidmFsdWVcIjogMFxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNdWx0aVN0YXRlQ2hlY2tib3godmFsdWUsIGluaXRTdGF0ZSwgc3RhdGVzPWRlZmF1bHRTdGF0ZXMpIHtcbiAgICBpZighT2JqZWN0LmtleXMoc3RhdGVzKS5pbmNsdWRlcyhpbml0U3RhdGUpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbml0aWFsIHN0YXRlXCIpXG4gICAgfVxuXG4gICAgbGV0IHN0YXRlID0gc3RhdGVzW2luaXRTdGF0ZV1cblxuICAgIGxldCAkaW5jbHVkZUJ1dHRvbiA9ICQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBzdHlsZXMuYnRuSW5jbHVkZSwgXCJhcmlhLWxhYmVsXCI6IGluaXRTdGF0ZSwgXCJ2YWx1ZVwiOiB2YWx1ZSwgZGF0YToge3N0YXRlOiBpbml0U3RhdGV9fSlcbiAgICAgICAgLmFwcGVuZCgkKFwiPHNwYW4+XCIsIHtcImNsYXNzXCI6IHN0YXRlLnRleHRDb2xvdXIsIGh0bWw6IHN0YXRlLnN5bWJvbH0pKVxuICAgICAgICAuYXBwZW5kKCQoXCI8c3Bhbj5cIiwge1wiY2xhc3NcIjogc3RhdGUuc3BhbkNsYXNzZXMgKyBcIiBcIiArIHN0eWxlcy5idG5IZWxwTGFiZWwsIHRleHQ6IHN0YXRlLnZhbHVlfSkuaGlkZSgpKVxuXG5cbiAgICAvLyBBZGQgZXZlbnRzIHRvIGJ1dHRvblxuICAgIHNldE11bHRpU3RhdGVDaGVja2JveExvZ2ljKCRpbmNsdWRlQnV0dG9uLCBzdGF0ZXMpXG5cbiAgICByZXR1cm4gJGluY2x1ZGVCdXR0b24uZ2V0KDApXG59XG5cblxuZnVuY3Rpb24gc2V0UGFyZW50SW5kZXRlcm1pbmF0ZShidXR0b24sIHBhcmVudEJ1dHRvbiwgc3RhdGVzKSB7XG4gICAgbGV0IG93blN0YXRlID0gYnV0dG9uLnZhbHVlIC8vXG4gICAgbGV0IHNpYmxpbmdzID0gYnV0dG9uLnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKCkuY2hpbGRyZW4oXCJzcGFuXCIpLmNoaWxkcmVuKFwiYnV0dG9uXCIpXG5cblxuICAgIGxldCBzaWJsaW5nU3RhdGVzID0gc2libGluZ3MubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9KVxuXG4gICAgaWYoc2libGluZ1N0YXRlcy50b0FycmF5KCkuZXZlcnkoc3RhdGUgPT4gc3RhdGUgPT09IG93blN0YXRlKSl7XG4gICAgICAgIHNldFN0YXRlT2ZCdXR0b24ocGFyZW50QnV0dG9uLCBvd25TdGF0ZSwgc3RhdGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlT2ZCdXR0b24ocGFyZW50QnV0dG9uLCBcImluZGV0ZXJtaW5hdGVcIiwgc3RhdGVzKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0TXVsdGlTdGF0ZUNoZWNrYm94TG9naWMoJGJ1dHRvbiwgc3RhdGVzPWRlZmF1bHRTdGF0ZXMpIHtcbiAgICAkYnV0dG9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgJGNsaWNrZWRCdXR0b24gPSAkKHRoaXMpXG4gICAgICAgIGxldCBuZXdTdGFnZSA9IHNldE5leHRTdGFnZSgkY2xpY2tlZEJ1dHRvbiwgc3RhdGVzKVxuXG4gICAgICAgIC8vIENoYW5nZSBjaGlsZHJlbiB0byB0aGUgc2FtZSBzdGF0ZVxuICAgICAgICBzZXRTdGF0ZU9mQ2hpbGRyZW4oJGNsaWNrZWRCdXR0b24sIG5ld1N0YWdlLCBzdGF0ZXMpXG5cbiAgICAgICAgbGV0ICRwYXJlbnRCdXR0b24gPSAkY2xpY2tlZEJ1dHRvbi5wYXJlbnQoKS5wYXJlbnQoKS5wYXJlbnQoKS5zaWJsaW5ncyhcImJ1dHRvblwiKVxuICAgICAgICBpZiAoJHBhcmVudEJ1dHRvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZXRQYXJlbnRJbmRldGVybWluYXRlKCRjbGlja2VkQnV0dG9uLCAkcGFyZW50QnV0dG9uLCBzdGF0ZXMpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gT24gbW91c2VvdmVyLCBzaG93IHRoZSB0ZXh0XG4gICAgJGJ1dHRvbi5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHRpbWVvdXQgdG8gcHJldmVudCB0aGUgdGV4dCBmcm9tIHNob3dpbmcgd2hlbiB0aGUgdXNlciBpcyBqdXN0IG1vdmluZyB0aGUgbW91c2VcbiAgICAgICAgbGV0ICRjbGlja2VkQnV0dG9uID0gJCh0aGlzKVxuICAgICAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0ICR0eXBlTGFiZWwgPSAkY2xpY2tlZEJ1dHRvbi5jaGlsZHJlbihcIi5cIiArIHN0eWxlcy5idG5IZWxwTGFiZWwpXG5cbiAgICAgICAgICAgIGlmICgkY2xpY2tlZEJ1dHRvbi5kYXRhKFwidGV4dFZhbHVlXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgJHR5cGVMYWJlbC5oaWRlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHR5cGVMYWJlbC5zaG93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKVxuICAgICAgICAkYnV0dG9uLmRhdGEoXCJ0aW1lb3V0XCIsIHRpbWVvdXQpXG4gICAgfSlcblxuICAgIC8vIE9uIG1vdXNlb3V0LCBoaWRlIHRoZSB0ZXh0XG4gICAgJGJ1dHRvbi5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCQodGhpcykuZGF0YShcInRpbWVvdXRcIikpXG4gICAgICAgIGxldCB0ZXh0ID0gJCh0aGlzKS5jaGlsZHJlbihcIi5cIiArIHN0eWxlcy5idG5IZWxwTGFiZWwpXG4gICAgICAgIHRleHQuaGlkZSgpXG4gICAgfSlcblxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZU9mQnV0dG9uKCRidXR0b24sIHN0YXRlLCBzdGF0ZXM9ZGVmYXVsdFN0YXRlcykge1xuICAgIGlmKCFPYmplY3Qua2V5cyhzdGF0ZXMpLmluY2x1ZGVzKHN0YXRlKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGVcIilcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGJ1dHRvbiB0byBpdHMgbmV3IHN0YXRlXG4gICAgJGJ1dHRvbi5hdHRyKFwiYXJpYS1sYWJlbFwiLCBzdGF0ZSlcbiAgICAgICAgLmRhdGEoXCJzdGF0ZVwiLCBzdGF0ZSlcbiAgICAgICAgLmRhdGEoXCJ0ZXh0VmFsdWVcIiwgc3RhdGVzW3N0YXRlXS52YWx1ZSlcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBzdHlsZXMuYnRuSW5jbHVkZSlcbiAgICAgICAgLmFkZENsYXNzKHN0YXRlc1tzdGF0ZV0udGV4dENvbG91cilcblxuICAgIC8vIFVwZGF0ZSB0aGUgaWNvblxuICAgIGxldCAkaWNvbiA9ICRidXR0b24uZmluZChcInNwYW5cIikuZmlyc3QoKS5hdHRyKFwiY2xhc3NcIiwgc3RhdGVzW3N0YXRlXS50ZXh0Q29sb3VyKVxuXG4gICAgLy8gVXBkYXRlIHRoZSBzeW1ib2xcbiAgICAkaWNvbi5lbXB0eSgpXG4gICAgJGljb24uYXBwZW5kKCQoc3RhdGVzW3N0YXRlXS5zeW1ib2wsIHtcImNsYXNzXCI6IHN0YXRlc1tzdGF0ZV0udGV4dENvbG91cn0pKVxuXG4gICAgLy8gVXBkYXRlIHRoZSB0ZXh0XG4gICAgJGJ1dHRvbi5maW5kKFwic3BhblwiKS5sYXN0KClcbiAgICAgICAgLnRleHQoc3RhdGVzW3N0YXRlXS52YWx1ZSlcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBzdGF0ZXNbc3RhdGVdLnNwYW5DbGFzc2VzICsgXCIgXCIgK3N0eWxlcy5idG5IZWxwTGFiZWwpXG4gICAgICAgIC5oaWRlKClcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVPZkNoaWxkcmVuKCRidXR0b24sIHN0YXRlLCBzdGF0ZXM9ZGVmYXVsdFN0YXRlcyl7XG4gICAgLy8gR2V0IGFsbCB0aGUgYnV0dG9ucyBpbiB0aGUgdW5vcmRlcmVkIGxpc3Qgd2l0aCB0aGUgY2xhc3Mgc3R5bGVzLmJ0bkluY2x1ZGVcbiAgICBsZXQgYnV0dG9ucyA9ICRidXR0b24uc2libGluZ3MoXCJ1bFwiKS5maW5kKFwiLlwiICsgc3R5bGVzLmJ0bkluY2x1ZGUpXG4gICAgYnV0dG9ucy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHNldFN0YXRlT2ZCdXR0b24oJCh0aGlzKSwgc3RhdGUsIHN0YXRlcylcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBzZXROZXh0U3RhZ2UoJGJ1dHRvbiwgc3RhdGVzKSB7XG5cbiAgICBsZXQgc3RhdGVLZXkgPSAkYnV0dG9uLmRhdGEoXCJzdGF0ZVwiKVxuXG4gICAgaWYoIU9iamVjdC5rZXlzKHN0YXRlcykuaW5jbHVkZXMoc3RhdGVLZXkpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiB0aGUgc3RhdGVzIGFuZCBnZXQgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHN0YXRlLCBzbyB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlXG4gICAgbGV0IHN0YXRlS2V5cyA9IE9iamVjdC5rZXlzKHN0YXRlcylcbiAgICBsZXQgc3RhdGVJbmRleCA9IHN0YXRlS2V5cy5pbmRleE9mKHN0YXRlS2V5KVxuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBuZXh0IHN0YXRlXG4gICAgbGV0IG5leHRTdGF0ZSA9IHN0YXRlS2V5c1soc3RhdGVJbmRleCArIDEpICUgc3RhdGVLZXlzLmxlbmd0aF1cblxuICAgIHdoaWxlKG5leHRTdGF0ZSA9PT0gXCJpbmRldGVybWluYXRlXCIpe1xuICAgICAgICBzdGF0ZUluZGV4ID0gc3RhdGVLZXlzLmluZGV4T2YobmV4dFN0YXRlKVxuICAgICAgICBuZXh0U3RhdGUgPSBzdGF0ZUtleXNbKHN0YXRlSW5kZXggKyAxKSAlIHN0YXRlS2V5cy5sZW5ndGhdXG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgYnV0dG9uXG4gICAgc2V0U3RhdGVPZkJ1dHRvbigkYnV0dG9uLCBuZXh0U3RhdGUsIHN0YXRlcylcbiAgICByZXR1cm4gbmV4dFN0YXRlXG59XG5leHBvcnQge2dlbmVyYXRlTXVsdGlTdGF0ZUNoZWNrYm94LCBzZXRTdGF0ZU9mQnV0dG9ufSIsImltcG9ydCAnc2hpbnknO1xuaW1wb3J0IHtDb25zdHJ1Y3RUcmVlfSBmcm9tIFwiLi9jb25zdHJ1Y3RUcmVlXCI7XG5pbXBvcnQge2NyZWF0ZUNhcmV0LCBjcmVhdGVDaGVja2JveExhYmVsLCBjcmVhdGVJbnB1dENoZWNrYm94LCBnZW5lcmF0ZUlELCBnZW5lcmF0ZVNlbGVjdEJ1dHRvbnN9IGZyb20gJy4vaGVscGVycyc7XG5cbmltcG9ydCB7Z2VuZXJhdGVNdWx0aVN0YXRlQ2hlY2tib3gsIHNldFN0YXRlT2ZCdXR0b259IGZyb20gXCIuL211bHRpU3RhdGVDaGVja2JveFwiO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3RyZWUuY3NzJ1xuXG5mdW5jdGlvbiBwcmVTZWxlY3ROb2RlcyhpZCwgc2VsZWN0ZWQsIGluY2x1ZGVNb2RlKSB7XG4gICAgbGV0ICRiYXNlID0gJChcIiNcIiArIGlkKVxuXG4gICAgaWYgKHR5cGVvZihzZWxlY3RlZCkgPT09IFwiYm9vbGVhblwiICYmIHNlbGVjdGVkID09PSB0cnVlKXtcbiAgICAgICAgaWYgKGluY2x1ZGVNb2RlID09PSB0cnVlKXtcbiAgICAgICAgICAgICRiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHNldFN0YXRlT2ZCdXR0b24odGhpcywgXCJpbmNsdWRlXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWlucHV0XCIpLnByb3Aoe2luZGV0ZXJtaW5hdGU6IGZhbHNlLCBjaGVja2VkOiB0cnVlfSl9XG4gICAgfVxuXG4gICAgZWxzZXtcblxuICAgICAgICAvLyBJZiBzZWxlY3RlZCBpcyBhIHN0cmluZyBwdXQgaXQgaW50byBhbiBhcnJheVxuICAgICAgICBpZiAodHlwZW9mKHNlbGVjdGVkKSA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IFtzZWxlY3RlZF1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHNlbGVjdGVkKXtcbiAgICAgICAgICAgIC8vIEFkZCBiYWNrc2xhc2ggdG8gdmFsdWUgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8oWyAjOyYsLisqflxcJzpcIiFeJFtcXF0oKT0+fFxcL0BdKS9nLCAnXFxcXCQxJylcblxuICAgICAgICAgICAgaWYgKGluY2x1ZGVNb2RlID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImluY2x1ZGVNb2RlOiBcIiArIGluY2x1ZGVNb2RlICsgXCIgdmFsdWU6IFwiICsgdmFsdWUpXG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvbiA9ICRiYXNlLmZpbmQoXCJpbnB1dFt2YWx1ZT0nXCIgKyB2YWx1ZSArIFwiJ11cIikuc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSlcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZU9mQnV0dG9uKGJ1dHRvbiwgXCJpbmNsdWRlXCIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5jbHVkZU1vZGU6IFwiICsgaW5jbHVkZU1vZGUgKyBcIiB2YWx1ZTogXCIgKyB2YWx1ZSlcblxuICAgICAgICAgICAgICAgIC8vIGJpbmQgdGhlIGNsYXNzICdncm91cGVkLWNoZWNrYm94LWlucHV0JyB0byB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICRiYXNlLmZpbmQoXCJpbnB1dFt2YWx1ZT0nXCIgKyB2YWx1ZSArIFwiJ11cIikucHJvcCh7aW5kZXRlcm1pbmF0ZTogZmFsc2UsIGNoZWNrZWQ6IHRydWV9KVxuXG5cbiAgICAgICAgICAgICAgICAvLyAkYmFzZS5maW5kKFwiLmdyb3VwZWQtY2hlY2tib3gtaW5wdXRbdmFsdWU9J1wiICsgdmFsdWUgKyBcIiddXCIpLnByb3Aoe2luZGV0ZXJtaW5hdGU6IGZhbHNlLCBjaGVja2VkOiB0cnVlfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb2xsYXBzZU5vZGVzKGlkLCBjb2xsYXBzZWQpIHtcbiAgICBpZiAodHlwZW9mKGNvbGxhcHNlZCkgPT09IFwiYm9vbGVhblwiICYmIGNvbGxhcHNlZCl7XG4gICAgICAgICQoXCIjXCIgKyBpZCkuZmluZChcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hDYXJldCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaGlkZUxpc3RFbGVtZW50KHRoaXMsIFwidG9nZ2xlXCIpXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbGxhcHNlZCkgfHwgdHlwZW9mKGNvbGxhcHNlZCkgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICBpZiAodHlwZW9mKGNvbGxhcHNlZCkgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICAgICAgY29sbGFwc2VkID0gW2NvbGxhcHNlZF1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGNvbGxhcHNlZCl7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhbICM7JiwuKyp+XFwnOlwiIV4kW1xcXSgpPT58XFwvQF0pL2csICdcXFxcJDEnKVxuXG4gICAgICAgICAgICBsZXQgY2FyZXQgPSAkKFwiI1wiICsgaWQpLmZpbmQoXCJpbnB1dFt2YWx1ZT0nXCIgKyB2YWx1ZSArIFwiJ11cIikuc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpO1xuICAgICAgICAgICAgaGlkZUxpc3RFbGVtZW50KGNhcmV0LCBcInRvZ2dsZVwiKVxuICAgICAgICB9XG5cbiAgICB9XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBidW5jaCBvZiBpbnB1dHMsIGNyZWF0ZXMgYSB0cmVlLCBhbmQgdGhlbiByZW5kZXJzIGl0XG4gKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGhvbGQgdGhlIHRyZWVcbiAqIEBwYXJhbSBsYWJlbCAtIFRoZSBsYWJlbCBmb3IgdGhlIHRyZWVcbiAqIEBwYXJhbSBjaG9pY2VzIC0gQSBsaXN0IG9mIGNob2ljZXMuIEVhY2ggY2hvaWNlIGlzIGEgbGlzdCBvZiBsZW5ndGggMiwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgY2hvaWNlLCBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSBsYWJlbC5cbiAqIEBwYXJhbSBsZXZlbHMgLSBBIHZlY3RvciBvZiBzdHJpbmdzIHRoYXQgaW5kaWNhdGUgdGhlIGxldmVscyBvZiB0aGUgdHJlZS5cbiAqIEBwYXJhbSBjb2xsYXBzZWQgLSBhIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHRyZWUgc2hvdWxkIGJlIGNvbGxhcHNlZCBieSBkZWZhdWx0XG4gKiBAcGFyYW0gc2VsZWN0ZWQgLSBBIHZlY3RvciBvZiB2YWx1ZXMgdGhhdCBzaG91bGQgYmUgc2VsZWN0ZWQsIElmIHByb3ZpZGVkIHRydWUuXG4gKiBAcGFyYW0gaW5jbHVkZU1vZGUgLSBBIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNoZWNrYm94ZXMgaGF2ZSBhbiBpbmNsdWRlL2V4Y2x1ZGUgbW9kZVxuICogQHBhcmFtIHJlbmRlclNlbGVjdEJ1dHRvbnMgLSBBIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNlbGVjdCBidXR0b25zIHNob3VsZCBiZSByZW5kZXJlZFxuICogQHBhcmFtIHJlbmRlclNlYXJjaEJhciAtIEEgYm9vbGVhbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgc2VhcmNoIGJhciBzaG91bGQgYmUgcmVuZGVyZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJlZShpZCwgbGFiZWwsIGNob2ljZXMsIGxldmVscywgY29sbGFwc2VkLCBzZWxlY3RlZCwgaW5jbHVkZU1vZGUsIHJlbmRlclNlbGVjdEJ1dHRvbnMsIHJlbmRlclNlYXJjaEJhcil7XG4gICAgbGV0ICRiYXNlID0gJChcIiNcIiArIGlkKVxuXG4gICAgaWYgKGxhYmVsKXtcbiAgICAgICAgJGJhc2UuYXBwZW5kKFwiPGg0PlwiICsgbGFiZWwgKyBcIjwvaDQ+XCIpXG4gICAgfVxuICAgIGlmIChyZW5kZXJTZWxlY3RCdXR0b25zID09PSB0cnVlKXtcbiAgICAgICAgJGJhc2UuYXBwZW5kKGdlbmVyYXRlU2VsZWN0QnV0dG9ucyhpZCwgbGV2ZWxzLmxlbmd0aCA+IDEsIGluY2x1ZGVNb2RlKSlcbiAgICB9XG5cbiAgICAkYmFzZS5kYXRhKFwiaW5jbHVkZU1vZGVcIiwgaW5jbHVkZU1vZGUpXG5cblxuICAgIGxldCB0cmVlID0gcGFyc2VUcmVlKGNob2ljZXMsIGxldmVscylcblxuICAgIGxldCAkbm9kZUNvbnRhaW5lciA9ICQoXCI8ZGl2PlwiLCB7XCJjbGFzc1wiOiBzdHlsZXMuZ3JvdXBlZENoZWNrYm94Tm9kZUhvbGRlciArIFwiIG92ZXJmbG93LWF1dG8gYWxpZ24tc2VsZi1jZW50ZXJcIn0pXG4gICAgJGJhc2UuYXBwZW5kKCRub2RlQ29udGFpbmVyKVxuXG4gICAgLy8gUmVuZGVyIGFuZCBhcHBlbmQgdGhlIG5vZGVzXG4gICAgYXBwZW5kTm9kZXMoJG5vZGVDb250YWluZXIuZ2V0KDApLCB0cmVlLCBpbmNsdWRlTW9kZSlcblxuXG5cbiAgICAvLyBIaWRlIHRoZSBub2Rlc1xuICAgIGlmIChsZXZlbHMubGVuZ3RoID4gMSl7XG4gICAgICAgIGNvbGxhcHNlTm9kZXMoaWQsIGNvbGxhcHNlZClcblxuICAgIH1cblxuXG4gICAgLy8gQ2hlY2sgd2hpY2ggbm9kZXMgc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAgcHJlU2VsZWN0Tm9kZXMoaWQsIHNlbGVjdGVkLCBpbmNsdWRlTW9kZSlcblxuXG4gICAgJChkb2N1bWVudCkub24oXCJzaGlueTpjb25uZWN0ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnRzKGlkKVxuICAgIH0pO1xuXG59XG5cbi8qKlxuICogSXQgdGFrZXMgYW4gZWxlbWVudCBhbmQgYW4gYW5pbWF0aW9uIHR5cGUsIGFuZCB0b2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBlbGVtZW50J3Mgc2libGluZ3NcbiAqIEBwYXJhbSBlbGVtZW50IC0gdGhlIGVsZW1lbnQgdGhhdCBpcyBjbGlja2VkIHRvIGhpZGUvc2hvd1xuICogQHBhcmFtIGFuaW1hdGlvbiAtIFwidG9nZ2xlXCIgb3IgXCJzbGlkZVwiXG4gKi9cbmZ1bmN0aW9uIGhpZGVMaXN0RWxlbWVudChlbGVtZW50LCBhbmltYXRpb249XCJ0b2dnbGVcIil7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHtcInRvZ2dsZVwiOiB7XCJzaG93XCI6IFwic2hvd1wiLCBcImhpZGVcIjogXCJoaWRlXCJ9LCBcInNsaWRlXCI6IHtcInNob3dcIjogXCJzbGlkZURvd25cIiwgXCJoaWRlXCI6IFwic2xpZGVVcFwifX1cblxuICAgIGxldCBjYXJldCA9ICQoZWxlbWVudClcbiAgICBpZiAoIShhbmltYXRpb24gaW4gYW5pbWF0aW9ucykpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYW5pbWF0aW9uIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cIilcblxuICAgIH1cblxuICAgIGlmIChjYXJldC50ZXh0KCkgPT09IFwi4pa8XCIpIHtcbiAgICAgICAgY2FyZXQudGV4dChcIuKWtlwiKVxuICAgICAgICBjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KVthbmltYXRpb25zW2FuaW1hdGlvbl1bXCJoaWRlXCJdXSgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FyZXQudGV4dChcIuKWvFwiKVxuICAgICAgICBjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KVthbmltYXRpb25zW2FuaW1hdGlvbl1bXCJzaG93XCJdXSgpXG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBJdCB0YWtlcyB0aGUgaWQgb2YgYSBjaGVja2JveEdyb3VwSW5wdXQsIGZpbmRzIGFsbCB0aGUgY2hlY2tib3hlcyB0aGF0IGFyZSBjaGVja2VkLCBhbmQgdGhlbiBzZXRzXG4gKiB0aGUgU2hpbnkgaW5wdXQgdG8gdGhlIHZhbHVlcyBvZiB0aGUgY2hlY2tlZCBjaGVja2JveGVzXG4gKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGNoZWNrYm94R3JvdXBJbnB1dFxuICovXG5mdW5jdGlvbiBzZXRJbnB1dChpZCl7XG5cbiAgICAvLyBHZXQgaW5jbHVkZU1vZGUgZnJvbSBkYXRhXG4gICAgbGV0IGluY2x1ZGVNb2RlID0gJChcIiNcIiArIGlkKS5kYXRhKFwiaW5jbHVkZU1vZGVcIilcblxuICAgIGxldCBzZWxlY3RlZFZhbHVlc1xuICAgIGlmIChpbmNsdWRlTW9kZSA9PT0gdHJ1ZSl7XG4gICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0SW5wdXRJbmNsdWRlZChpZClcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0SW5wdXRSZWd1bGFyKGlkKVxuICAgIH1cblxuICAgIFNoaW55LnNldElucHV0VmFsdWUoaWQsIHNlbGVjdGVkVmFsdWVzLCB7cHJpb3JpdHk6IFwiZXZlbnRcIn0pO1xuXG59XG5cbmZ1bmN0aW9uIGdldElucHV0UmVndWxhcihpZCl7XG4gICAgbGV0ICRiYXNlID0gJChcIiNcIiArIGlkKVxuICAgIGxldCBzZWxlY3RlZCA9IFtdXG5cbiAgICAkYmFzZS5maW5kKFwiaW5wdXQ6Y2hlY2tib3g6Y2hlY2tlZFwiKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBjaGVja2JveCA9ICQodGhpcylcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY2hlY2tib3ggaGFzIGNoaWxkcmVuIGFzIHdlIG9ubHkgbmVlZCBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgaWYgKGNoZWNrYm94LnNpYmxpbmdzKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGNoZWNrYm94LnZhbCgpKVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBzZWxlY3RlZFxuXG59XG5cbmZ1bmN0aW9uIGdldElucHV0SW5jbHVkZWQoaWQpe1xuICAgIGxldCAkYnV0dG9ucyA9ICQoXCIjXCIgKyBpZCkuZmluZChcIi5cIiArIHN0eWxlcy5idG5JbmNsdWRlKVxuXG4gICAgbGV0IHNlbGVjdGVkID0ge1wiaW5jbHVkZWRcIjogW10sIFwiZXhjbHVkZWRcIjogW119XG4gICAgZm9yIChjb25zdCBidXR0b24gb2YgJGJ1dHRvbnMpIHtcbiAgICAgICAgbGV0ICRidXR0b24gPSAkKGJ1dHRvbilcbiAgICAgICAgaWYgKCRidXR0b24uc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94TGlzdCkubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9ICRidXR0b24uZGF0YShcInN0YXRlXCIpXG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IFwiaW5jbHVkZVwiKXtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFtcImluY2x1ZGVkXCJdLnB1c2goJGJ1dHRvbi52YWwoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09PSBcImV4Y2x1ZGVcIil7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRbXCJleGNsdWRlZFwiXS5wdXNoKCRidXR0b24udmFsKCkpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbn1cblxuXG5mdW5jdGlvbiByZWdpc3RlckluY2x1ZGVNb2RlRXZlbnRzKGlkKSB7XG4gICAgbGV0ICRiYXNlID0gJChcIiNcIiArIGlkKVxuICAgICRiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICBzZXRJbnB1dChpZClcbiAgICB9KVxufVxuXG5mdW5jdGlvbiByZWdpc3RlclJlZ3VsYXJNb2RlRXZlbnRzKGlkKSB7XG4gICAgbGV0ICRiYXNlID0gJChcIiNcIiArIGlkKVxuICAgICRiYXNlLmZpbmQoXCIuZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gU2VsZWN0IGFsbCBjaGlsZHJlbiBhbmQgY2hhbmdlIHByb3AgY2hlY2tlZFxuICAgICAgICBsZXQgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICAgICRlbGVtZW50LnNpYmxpbmdzKFwidWxcIikuY2hpbGRyZW4oKS5maW5kKFwiLmdyb3VwZWQtY2hlY2tib3gtaW5wdXRcIikucHJvcChcImNoZWNrZWRcIiwgJGVsZW1lbnQuaXMoXCI6Y2hlY2tlZFwiKSlcblxuICAgICAgICAvLyBJZiBub3QgYWxsIGNoaWxkcmVuIGhhdmUgdGhlIHNhbWUgY2hlY2sgdmFsdWUsIHNldCBwYXJlbnQgdG8gaW5kZXRlcm1pbmF0ZS5cbiAgICAgICAgbGV0IGNoZWNrU3RhdHVzID0gWyRlbGVtZW50LmlzKFwiOmNoZWNrZWRcIildXG4gICAgICAgICRlbGVtZW50LnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKCkuY2hpbGRyZW4oKS5jaGlsZHJlbihcImlucHV0W3R5cGU9J2NoZWNrYm94J11cIikuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2hlY2tTdGF0dXMucHVzaCgkKHRoaXMpLmlzKFwiOmNoZWNrZWRcIikpXG4gICAgICAgIH0pXG5cblxuICAgICAgICBsZXQgdW5pcXVlVmFsdWVzID0gWy4uLiBuZXcgU2V0KGNoZWNrU3RhdHVzKV1cblxuICAgICAgICAvLyBHZXQgcGFyZW50IGNoZWNrYm94IHdoaWNoIGluZGVydGVybWluYXRlIG5lZWRzIHRvbyBjaGFuZ2UuIEFuZCBzZXQgaW5kZXRlcm1pbmF0ZVxuICAgICAgICBsZXQgJHBhcmVudENoZWNrYm94ID0gJGVsZW1lbnQucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkuc2libGluZ3MoXCIuZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiKVxuICAgICAgICBpZiAodW5pcXVlVmFsdWVzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgJHBhcmVudENoZWNrYm94LnByb3Aoe2luZGV0ZXJtaW5hdGU6IHRydWUsIGNoZWNrZWQ6IGZhbHNlfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRwYXJlbnRDaGVja2JveC5wcm9wKHtpbmRldGVybWluYXRlOiBmYWxzZSwgY2hlY2tlZDogJGVsZW1lbnQuaXMoXCI6Y2hlY2tlZFwiKX0pXG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5wdXQoaWQpXG4gICAgfSlcblxufVxuXG4vKiBSZWdpc3RlcmluZyBldmVudHMgZm9yIHRoZSBjaGVja2JveGVzLiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoaWQpe1xuICAgIGxldCAkYmFzZSA9ICQoXCIjXCIgKyBpZClcblxuICAgIC8vIEhpZGUgaWYgY2FyZXQgaXMgY2xpY2tlZFxuICAgICRiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCl7XG4gICAgICAgIGhpZGVMaXN0RWxlbWVudCh0aGlzLCBcInRvZ2dsZVwiKVxuICAgIH0pXG5cbiAgICBsZXQgaW5jbHVkZU1vZGUgPSAkYmFzZS5kYXRhKFwiaW5jbHVkZU1vZGVcIilcblxuICAgIGlmIChpbmNsdWRlTW9kZSA9PT0gdHJ1ZSl7XG4gICAgICAgIHJlZ2lzdGVySW5jbHVkZU1vZGVFdmVudHMoaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVnaXN0ZXJSZWd1bGFyTW9kZUV2ZW50cyhpZClcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGdyb3VwIGNoZWNrYm94IGdldCBjaGFuZ2VkLCBzbyB3aWxsIGNoaWxkcmVuXG5cblxuICAgIC8vIFNlbGVjdCBhbGwgYnV0dG9uXG4gICAgJGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LXNlbGVjdC1hbGxcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICAkYmFzZS5maW5kKFwiLmdyb3VwZWQtY2hlY2tib3gtaW5wdXRcIikucHJvcCh7aW5kZXRlcm1pbmF0ZTogZmFsc2UsIGNoZWNrZWQ6IHRydWV9KVxuICAgICAgICBzZXRJbnB1dChpZClcblxuICAgIH0pXG5cbiAgICAvLyBEZXNlbGVjdCBhbGxcbiAgICAkYmFzZS5maW5kKFwiLmdyb3VwZWQtY2hlY2tib3gtZGVzZWxlY3QtYWxsXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKGluY2x1ZGVNb2RlID09PSB0cnVlKXtcbiAgICAgICAgICAgIC8vIElmIGluY2x1ZGUgbW9kZSwgZGVzZWxlY3QgYWxsIGJ1dHRvbnNcbiAgICAgICAgICAgICRiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHNldFN0YXRlT2ZCdXR0b24oJCh0aGlzKSwgXCJ1bmNoZWNrZWRcIilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYmFzZS5maW5kKFwiLmdyb3VwZWQtY2hlY2tib3gtaW5wdXRcIikucHJvcCh7aW5kZXRlcm1pbmF0ZTogZmFsc2UsIGNoZWNrZWQ6IGZhbHNlfSlcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnB1dChpZClcbiAgICB9KVxuXG4gICAgLy8gRXhwYW5kIGFsbCBidXR0b25cbiAgICAkYmFzZS5maW5kKFwiLmdyb3VwZWQtY2hlY2tib3gtZXhwYW5kLWFsbFwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgICRiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCAkY2FyZXQgPSAkKHRoaXMpXG4gICAgICAgICAgICBpZiAoJGNhcmV0LnRleHQoKSA9PT0gXCLilrZcIikge1xuICAgICAgICAgICAgICAgICRjYXJldC50ZXh0KFwi4pa8XCIpXG4gICAgICAgICAgICAgICAgJGNhcmV0LnNpYmxpbmdzKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpLnNob3coKVxuICAgICAgICAgICAgICAgICRjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KS5zaG93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxuICAgIFxuXG4gICAgLy8gQ29sbGFwc2UgYWxsIGJ1dHRvblxuICAgICRiYXNlLmZpbmQoXCIuZ3JvdXBlZC1jaGVja2JveC1jb2xsYXBzZS1hbGxcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICAkYmFzZS5maW5kKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveENhcmV0KS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsZXQgJGNhcmV0ID0gJCh0aGlzKVxuICAgICAgICAgICAgaWYgKCRjYXJldC50ZXh0KCkgPT09IFwi4pa8XCIpIHtcbiAgICAgICAgICAgICAgICAkY2FyZXQudGV4dChcIuKWtlwiKVxuICAgICAgICAgICAgICAgICRjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KS5oaWRlKClcbiAgICAgICAgICAgICAgICAkY2FyZXQuc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94TGlzdCkuaGlkZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIEluY2x1ZGUgYWxsXG4gICAgJGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWluY2x1ZGUtYWxsXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gZmluZCBhbGwgYnV0dG9ucyBhbmQgc2V0IHRoZW0gdG8gaW5jbHVkZVxuICAgICAgICAkYmFzZS5maW5kKFwiLlwiICsgc3R5bGVzLmJ0bkluY2x1ZGUpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNldFN0YXRlT2ZCdXR0b24oJCh0aGlzKSwgXCJpbmNsdWRlXCIpXG4gICAgICAgIH0pXG4gICAgICAgIHNldElucHV0KGlkKVxuICAgIH0pXG5cbiAgICAvLyBFeGNsdWRlIGFsbFxuICAgICRiYXNlLmZpbmQoXCIuZ3JvdXBlZC1jaGVja2JveC1leGNsdWRlLWFsbFwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBmaW5kIGFsbCBidXR0b25zIGFuZCBzZXQgdGhlbSB0byBpbmNsdWRlXG4gICAgICAgICRiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZU9mQnV0dG9uKCQodGhpcyksIFwiZXhjbHVkZVwiKVxuICAgICAgICB9KVxuICAgICAgICBzZXRJbnB1dChpZClcbiAgICB9KVxuXG4gICAgLy8gSWYgbGFiZWwgaXMgY2xpY2tlZCwgY2hlY2sgdGhlIGNoZWNrYm94IGFuZCBpdHMgY2hpbGRyZW4gY2hlY2tib3hlc1xuICAgICRiYXNlLmZpbmQoXCIuXCIgKyBcImZvcm0tY2hlY2stbGFiZWxcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICBpZiAoJGJhc2UuZGF0YShcImluY2x1ZGVNb2RlXCIpID09PSB0cnVlKXtcbiAgICAgICAgICAgICQodGhpcykuc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkudHJpZ2dlcihcImNsaWNrXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKHRoaXMpLnNpYmxpbmdzKFwiLmdyb3VwZWQtY2hlY2tib3gtaW5wdXRcIikudHJpZ2dlcihcImNsaWNrXCIpXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy9TZXQgaW5wdXRcbiAgICBzZXRJbnB1dChpZClcbn1cblxuXG5cblxuLyoqXG4gKiA+IFRoZSBmdW5jdGlvbiBgcGFyc2VUcmVlYCB0YWtlcyB0d28gYXJndW1lbnRzLCBgY2hvaWNlc2AgYW5kIGBsZXZlbHNgLCBhbmQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZVxuICogb2YgdGhlIGBDb25zdHJ1Y3RUcmVlYCBjbGFzc1xuICogQHBhcmFtIGNob2ljZXMgLSBhbiBPYmplY3Qgd2l0aCB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBsZXZlbHMgLSB0aGUgbnVtYmVyIG9mIGxldmVscyBpbiB0aGUgdHJlZVxuICogQHJldHVybnMgQSBDb25zdHJ1Y3RUcmVlIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYXJzZVRyZWUoY2hvaWNlcywgbGV2ZWxzKXtcbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdFRyZWUoY2hvaWNlcywgbGV2ZWxzKVxufVxuXG4vKipcbiAqID4gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHRyZWUgT2JqZWN0IGFuZCBhcHBlbmRzIHRoZSBub2RlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0gcGFyZW50IC0gdGhlIHBhcmVudCBlbGVtZW50IHRvIGFwcGVuZCB0aGUgbm9kZXMgdG9cbiAqIEBwYXJhbSB0cmVlIC0gdGhlIHRyZWUgb2JqZWN0XG4gKiBAcGFyYW0gaW5jbHVkZU1vZGVcbiAqL1xuZnVuY3Rpb24gYXBwZW5kTm9kZXMocGFyZW50LCB0cmVlLCBpbmNsdWRlTW9kZSkge1xuICAgIGxldCBiYXNlID0gJChwYXJlbnQpXG4gICAgYmFzZS5hcHBlbmQoJChcIjx1bD5cIiwge1wiY2xhc3NcIjogc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QsIFwiaWRcIjogXCJncm91cGVkLWNoZWNrYm94LWxpc3QtYmFzZVwifSkpXG5cblxuICAgIGxldCBxdWV1ZSA9IFtdXG4gICAgcXVldWUucHVzaCh0cmVlLnJvb3QpXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IHNpemUgPSBxdWV1ZS5sZW5ndGhcbiAgICAgICAgbGV0IGN1cnJlbnRcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudCA9IHF1ZXVlLnNoaWZ0KClcblxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY3VycmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudC52YWx1ZSA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaHRtbElEID0gY29uc3RydWN0Tm9kZShjaGlsZC52YWx1ZSwgbnVsbCwgY2hpbGQuaGFzX2NoaWxkcmVuLCBiYXNlLCBpbmNsdWRlTW9kZSlcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuaHRtbElEID0gY29uc3RydWN0Tm9kZShjaGlsZC52YWx1ZSwgY2hpbGQucGFyZW50LCBjaGlsZC5oYXNfY2hpbGRyZW4sIGJhc2UsIGluY2x1ZGVNb2RlKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEl0IGNyZWF0ZXMgYSBuZXcgbm9kZSwgYXNzaWducyBpdCBhbiBJRCwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gbm9kZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbm9kZVxuICogQHBhcmFtIG5vZGVQYXJlbnQgLSBUaGUgcGFyZW50IG5vZGUgb2YgdGhlIG5vZGUgeW91J3JlIGNyZWF0aW5nLlxuICogQHBhcmFtIGhhc0NoaWxkcmVuIC0gYm9vbGVhblxuICogQHBhcmFtIGJhc2VcbiAqIEBwYXJhbSBpbmNsdWRlXG4gKiBAcmV0dXJucyBUaGUgSUQgb2YgdGhlIG5vZGUgdGhhdCB3YXMganVzdCBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3ROb2RlKG5vZGVOYW1lLCBub2RlUGFyZW50LCBoYXNDaGlsZHJlbiwgYmFzZSwgaW5jbHVkZSl7XG4gICAgLy8gdGhpcyBmdW5jdGlvbiB1c2VzIHBsYWluIEpTIHdoaWNoIGluY3JlYXNlcyB0aGUgc3BlZWQgaXQgdGFrZXMgdG8gcmVuZGVyIHRoZSBub2RlcyBieSBmb3VyIHRpbWVzIGluIGNvbXBhcmlzb25cbiAgICAvLyB3aXRoIHRoZSBtb3JlIHJlYWRhYmxlIGpxdWVyeSAgICBcblxuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKCFub2RlUGFyZW50KXtcbiAgICAgICAgcGFyZW50ID0gYmFzZS5jaGlsZHJlbigkKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpKVswXVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IGJhc2UuZmluZChcIiNjaGVja2JveC1saXN0LVwiICsgbm9kZVBhcmVudC5odG1sSUQpWzBdXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIElEIGZvciB0aGUgbm9kZXNcbiAgICBsZXQgbk5vZGVzID0gZ2VuZXJhdGVJRCgpXG4gICAgbGV0IG5ld05vZGVJRCA9IFwibm9kZS1cIiArIG5Ob2Rlc1xuXG4gICAgbGV0IG5vZGVMaXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKVxuXG5cbiAgICAvLyBDcmVhdGUgbm9kZSBhbmQgYXNzaWduIGNsYXNzZXNcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKFwiR3JvdXBlZENoZWNrQm94LW5vZGVcIiwgXCJ0ZXh0LWZnXCIpXG4gICAgbm9kZS5pZCA9IG5ld05vZGVJRFxuXG5cbiAgICBpZiAoaGFzQ2hpbGRyZW4pe1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNyZWF0ZUNhcmV0KCkpXG4gICAgfSBcblxuXG5cbiAgICAvLyBDaGVjayBpZiAnaW5jbHVkZScgaXMgdHJ1ZSBvciBmYWxzZVxuICAgIGlmIChpbmNsdWRlID09PSB0cnVlKXtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChnZW5lcmF0ZU11bHRpU3RhdGVDaGVja2JveChub2RlTmFtZSxcImluY2x1ZGVcIikpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVJbnB1dENoZWNrYm94KG5vZGVOYW1lLCBuTm9kZXMpKVxuICAgIH1cbiAgICBub2RlLmFwcGVuZENoaWxkKGNyZWF0ZUNoZWNrYm94TGFiZWwobm9kZU5hbWUsIG5Ob2RlcykpXG4gICAgICAgIFxuXG4gICAgaWYgKGhhc0NoaWxkcmVuKXtcbiAgICAgICAgbGV0IG5ld0xpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIilcbiAgICAgICAgbmV3TGlzdC5jbGFzc0xpc3QuYWRkKHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KVxuICAgICAgICBuZXdMaXN0LmlkID0gXCJjaGVja2JveC1saXN0LVwiICsgbmV3Tm9kZUlEXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3TGlzdClcbiAgICB9XG5cbiAgICBub2RlTGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZUxpc3RFbGVtZW50KVxuXG4gICAgcmV0dXJuIG5ld05vZGVJRFxufVxuXG5leHBvcnQge2NyZWF0ZVRyZWV9IiwibW9kdWxlLmV4cG9ydHMgPSBIVE1MV2lkZ2V0czsiLCJtb2R1bGUuZXhwb3J0cyA9IFNoaW55OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsImltcG9ydCAnd2lkZ2V0cyc7XG5pbXBvcnQgJ3NoaW55JztcblxuaW1wb3J0IHtjcmVhdGVUcmVlfSBmcm9tIFwiLi4vbW9kdWxlcy9yZW5kZXJUcmVlLmpzXCI7XG5cbkhUTUxXaWRnZXRzLndpZGdldCh7XG5cbiAgbmFtZTogJ3RyZWVjaGVja2JveCcsXG5cbiAgdHlwZTogJ291dHB1dCcsXG5cbiAgZmFjdG9yeTogZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgIC8vIFRPRE86IGRlZmluZSBzaGFyZWQgdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlXG5cbiAgICByZXR1cm4ge1xuXG4gICAgICByZW5kZXJWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICBjcmVhdGVUcmVlKGVsLmlkLCB4LmxhYmVsLCB4LmNob2ljZXMsIHgubGV2ZWxzLCB4LmNvbGxhcHNlZCwgeC5zZWxlY3RlZCwgeC5pbmNsdWRlTW9kZSwgeC5zZWxlY3RfYnV0dG9ucywgeC5zZWFyY2hfYmFyKVxuXG4gICAgICAgIC8vIEhUTUxXaWRnZXRzLndpZGdldCBzZXRzIGEgZGVmYXVsdCBzaXplLiBSZW1vdmUgdGhpcyBkZWZhdWx0IHNpemUgYW5kIG1ha2UgYXV0by5cbiAgICAgICAgJChcIiNcIiArIGVsLmlkKS5jc3MoXCJoZWlnaHRcIiwgXCJhdXRvXCIpLmNzcyhcIndpZHRoXCIsIFwiYXV0b1wiKVxuICAgICAgfSxcblxuICAgICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgLy8gVE9ETzogY29kZSB0byByZS1yZW5kZXIgdGhlIHdpZGdldCB3aXRoIGEgbmV3IHNpemVcblxuICAgICAgfVxuXG4gICAgfTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=