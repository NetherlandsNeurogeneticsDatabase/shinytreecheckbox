/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./srcjs/modules/tree.css":
/*!**************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./srcjs/modules/tree.css ***!
  \**************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Style the caret/arrow */\n.UNwkxeu8JaLUR7zsLOLc {\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none; /* Prevent text selection */\n  display: inline-block;\n  margin-right: 6px;\n}\n\n.dpG9VJCbE1T3hvNqWAXQ {\n  list-style: none;\n}\n\n.fRDpmJJ9MRXanERdlguP {\n  background-color: white;\n  border-radius: 8px;\n  border: 1px solid #cccccc;\n  max-height: 25vh;\n}\n\n.GmtEMuE1BhBuOK4UDeoJ {\n  width: 16px;\n  height: 16px;\n  padding: 1px;\n  margin-left: 2px;\n  margin-right: 2px;\n  text-align: center;\n  display: inline-block;\n  line-height: 15px;\n}\n\n.GmtEMuE1BhBuOK4UDeoJ:hover {\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  height: -webkit-fit-content;\n  height: -moz-fit-content;\n  height: fit-content;\n  min-width: 16px;\n  min-height: 16px;\n}\n\n.qIPVtNod_iQXqPR5gItw {\n  border-radius: 4px;\n  border-color: orange;\n  border-style: solid;\n  border-width: 1.17px;\n  color: orange;\n}\n\n.qIPVtNod_iQXqPR5gItw:hover {\n  width: 16px;\n  height: 16px;\n  padding: 1px;\n  border-radius: 4px;\n  border-color: orange;\n  border-style: solid;\n  border-width: 1.17px;\n  color: orange;\n}/*# sourceMappingURL=tree.css.map */", "",{"version":3,"sources":["webpack://./srcjs/modules/tree.scss","webpack://./srcjs/modules/tree.css"],"names":[],"mappings":"AACA,0BAAA;AACA;EACE,eAAA;EACA,yBAAA;KAAA,sBAAA;MAAA,qBAAA;UAAA,iBAAA,EAAA,2BAAA;EACA,qBAAA;EACA,iBAAA;ACAF;;ADGA;EACE,gBAAA;ACAF;;ADGA;EACE,uBAAA;EACA,kBAAA;EACA,yBAAA;EACA,gBAAA;ACAF;;ADIA;EACE,WAAA;EACA,YAAA;EACA,YAAA;EACA,gBAAA;EACA,iBAAA;EACA,kBAAA;EACA,qBAAA;EACA,iBAAA;ACDF;;ADIA;EACE,0BAAA;EAAA,uBAAA;EAAA,kBAAA;EACA,2BAAA;EAAA,wBAAA;EAAA,mBAAA;EAEA,eAAA;EACA,gBAAA;ACFF;;ADKA;EACE,kBAAA;EACA,oBAAA;EACA,mBAAA;EACA,oBAAA;EACA,aAAA;ACFF;;ADKA;EACE,WAAA;EACA,YAAA;EACA,YAAA;EACA,kBAAA;EACA,oBAAA;EACA,mBAAA;EACA,oBAAA;EACA,aAAA;ACFF,CAAA,mCAAA","sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"groupedCheckboxCaret": "UNwkxeu8JaLUR7zsLOLc",
	"groupedCheckboxList": "dpG9VJCbE1T3hvNqWAXQ",
	"groupedCheckboxNodeHolder": "fRDpmJJ9MRXanERdlguP",
	"btnInclude": "GmtEMuE1BhBuOK4UDeoJ",
	"btnIndeterminate": "qIPVtNod_iQXqPR5gItw"
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ }),

/***/ "./srcjs/modules/tree.css":
/*!********************************!*\
  !*** ./srcjs/modules/tree.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./tree.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[0].use[1]!./srcjs/modules/tree.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_0_use_1_tree_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./srcjs/modules/constructTree.js":
/*!****************************************!*\
  !*** ./srcjs/modules/constructTree.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstructTree": () => (/* binding */ ConstructTree)
/* harmony export */ });


/* The ConstructTree class takes in a list of records and a list of levels, and builds a tree of nodes
where each node represents a level and each node's children represent the next level */
class ConstructTree {
    root
    constructor(data, levels) {
        this.buildTree(data, levels)
    }


/**
 * > The function takes in a data set and a list of levels, and builds a tree with the data set
 * @param data - the data you want to build the tree from
 * @param levels - an array of strings that represent the levels of the tree.
 */
    buildTree(data, levels){
        let root = new Node("root")
        let newData

        data.forEach(record => {
            newData = []
            levels.forEach(level => {
                newData.push(record[level])
            })
            this.#findOrAppend(root, newData)
        })
        this.root = root
    }

/**
 * Returns the max depth of the tree
 * @returns The depth of the tree
 */
    findMaxDepth(){
        let queue = []
        let depth = 0

        queue.push(this.root)

        while(queue.length > 0){
            let size = queue.length

            let current

            for (let i = 0; i < size ; i++){
                current = queue.shift()

                for (let child of current.children){
                    queue.push(child)
                }
            }
            depth ++
        }
        return depth - 1
    }

/**
 * > Given a tree and a list of values, find the node in the tree that matches the last value in the
 * list, and if it doesn't exist, create it
 * @param tree - the tree to search
 * @param values - an array of values to be added to the tree
 * @returns The tree with the new values added.
 */
    #findOrAppend(tree, values){
        for (let i = 0; i < values.length ; i++){
            let keyQueue = values.slice(0, i + 1)
            let value = values[i]
            let [nodeIn, _] = this.#recursiveSearch(tree, keyQueue)
            if (nodeIn.value !== value){
                let newNode = new Node(value)
                nodeIn.add_child(newNode)
            }
        }
        return(tree)
    }
    
/**
 * > The function takes a node and a list of values to find. It returns the node that matches the last
 * value in the list, and the list of values that were not found
 * @param node - the node that we are currently searching
 * @param find - an array of strings that represent the path to the node you want to find
 * @returns The node that is the last in the path, and the path that is left to be searched.
 */
    #recursiveSearch(node, find){
        let children = node.children
        for (const child of children) {
            let finding = find[0]
            if (finding === child.value){
                find.shift()
                if (find.length > 0){
                    return this.#recursiveSearch(child, find)
                } else {
                    return([child, find])
                }
            }
        }
        return [node, find]
    }


}


/* A node is a value, a list of children, and a parent */
class Node{
    constructor(value, children, parent) {
        if (!children){
            children = []
        }
        this.value = value
        this.children = children
        this.parent = parent
        this.depth = 0
    }

    /*
     * Add children to node, and register parent in child.
     */
    add_child(child){
        this.children.push(child)
        this.children.forEach(child => {
            child.addParent(this)
        })
    }

    addParent(parent){
        this.parent = parent
        this.depth = parent.depth + 1
    }

    get has_children(){
        return((this.children.length > 0))
    }

    get siblings(){
        return this.parent.children
    }

    findObjectByName(name){
        if (this.value === name){
            return this
        } else {
            for (const child of this.children){
                let match = child.findObjectByName(name)
                if (match){
                    return match
                }
            }
        }
    }
}




/***/ }),

/***/ "./srcjs/modules/helpers.js":
/*!**********************************!*\
  !*** ./srcjs/modules/helpers.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createCaret": () => (/* binding */ createCaret),
/* harmony export */   "createCheckboxLabel": () => (/* binding */ createCheckboxLabel),
/* harmony export */   "createInputCheckbox": () => (/* binding */ createInputCheckbox),
/* harmony export */   "generateID": () => (/* binding */ generateID),
/* harmony export */   "generateSelectButtons": () => (/* binding */ generateSelectButtons)
/* harmony export */ });
/* harmony import */ var _tree_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tree.css */ "./srcjs/modules/tree.css");


/* A function that generates a unique ID. */
let generateID = (function(n) {
    return function() {
        n += 1
        return n;
    }
}(-1))


/**
 * It creates a span element, adds the class `groupedCheckboxCaret` to it, and sets its inner text to
 * "▼".
 * @returns A span element with the class "groupedCheckboxCaret" and the inner text "▼"
 */
 function createCaret(){
    let caret = document.createElement("span")
    caret.classList.add(_tree_css__WEBPACK_IMPORTED_MODULE_0__["default"].groupedCheckboxCaret)
    caret.innerText = "▼"
    return(caret)
}


/**
 * It creates a checkbox input element
 * @param nodeName - The name of the node
 * @param nodeID - The ID of the node.
 * @returns The inputCheckbox element
 */
 function createInputCheckbox(nodeName, nodeID) {
    let inputCheckbox = document.createElement("input")
    inputCheckbox.classList.add("grouped-checkbox-input", "form-check-input")
    inputCheckbox.type = "checkbox"
    inputCheckbox.value = nodeName
    inputCheckbox.id = "node-input-check" + nodeID
    return(inputCheckbox)
}

/**
 * It creates a label for a checkbox
 * @param nodeName - the name of the node
 * @param id - the id of the node
 * @returns A label element
 */
function createCheckboxLabel(nodeName, id){
    let labelCheckbox = document.createElement("label")
    labelCheckbox.classList.add("form-check-label")
    labelCheckbox.for = "node-input-check" + id
    labelCheckbox.innerHTML = nodeName
    return(labelCheckbox)
}

/**
 * It generates a container with two buttons, one to select all checkboxes and one to deselect all
 * checkboxes
 * @returns A div with two buttons.
 */
 function generateSelectButtons(){
    let container = $("<div>", {"class": "d-flex justify-content-evenly"})
    container.append($("<button>", {"class": "flex-child grouped-checkbox-select-all btn btn-outline-fg",
        "id": "grouped-checkbox-select-all-" + generateID(), "css": {"font-size": "x-small"}}).text("Select All"))
    container.append($("<button>", {"class": "flex-child grouped-checkbox-deselect-all btn btn-outline-fg",
        "id": "grouped-checkbox-deselect-all-" + generateID(), "css": {"font-size": "x-small"}}).text("Deselect All"))

    container.append($("<button>", {"class": "flex-child grouped-checkbox-expand-all btn btn-outline-fg", 
    "id": "grouped-checkbox-expand-all-" + generateID(), "css": {"font-size": "x-small"}}).text("Expand All"))

    container.append($("<button>", {"class": "flex-child grouped-checkbox-collapse-all btn btn-outline-fg", 
    "id": "grouped-checkbox-collapse-all-" + generateID(), "css": {"font-size": "x-small"}}).text("Collapse All"))
   
    return(container)
}



/***/ }),

/***/ "./srcjs/modules/renderTree.js":
/*!*************************************!*\
  !*** ./srcjs/modules/renderTree.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTree": () => (/* binding */ createTree)
/* harmony export */ });
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shiny */ "shiny");
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shiny__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _constructTree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constructTree */ "./srcjs/modules/constructTree.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./srcjs/modules/helpers.js");
/* harmony import */ var _tree_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tree.css */ "./srcjs/modules/tree.css");





/**
 * It takes an element and an animation type, and toggles the visibility of the element's siblings
 * @param element - the element that is clicked to hide/show
 * @param animation - "toggle" or "slide"
 */
function hideListElement(element, animation="toggle"){
    const animations = {"toggle": {"show": "show", "hide": "hide"}, "slide": {"show": "slideDown", "hide": "slideUp"}}

    let caret = $(element)
    if (!(animation in animations)){
        throw new Error("The animation type is not supported.")

    }

    let collapsedStatus
    if (caret.text() == "▼") {
        caret.text("▶")
        caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList)[animations[animation]["hide"]]()
        collapsedStatus = "collapsed"
    } else {
        caret.text("▼")
        caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList)[animations[animation]["show"]]()
        collapsedStatus = "expanded"
    }
}



/**
 * It takes the id of a checkboxGroupInput, finds all the checkboxes that are checked, and then sets
 * the Shiny input to the values of the checked checkboxes
 * @param id - The id of the checkboxGroupInput
 */
function setInput(id){
    
    // Check if element with id 'id' has children with the button class 'styles.btnInclude'

    // Checks if mode is "include" by finding the button with the class "styles.btnInclude
    let includeMode = $("#" + id).find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).length > 0

    let selected
    if (includeMode){
        selected = {"included": [], "excluded": []}
    } else {
        selected = []
    }



    $("#" + id).find("input:checkbox:checked").each(function(){
        let checkbox = $(this)

        // Check if the checkbox has children as we only need attribute names
        if (checkbox.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList).length === 0){
            if (includeMode){

                 // Include mode returns two lists, one with the included attributes and one with the excluded attributes
                let state = checkbox.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).text()
                if (state == "INCLUDE") {
                    selected["included"].push(checkbox.val())
                } else {
                    selected["excluded"].push(checkbox.val())
                }
            } else {
                // Normal mode returns a single list with the included attributes
                selected.push(checkbox.val())
            }
        }
    })
            
    // Set output
    Shiny.setInputValue(id, selected, {priority: "event"});

}

/* Registering events for the checkboxes. */
function registerEvents(id){

    let base = $("#" + id)

    // Hide if caret is clicked
    base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxCaret).on("click", function (){
        hideListElement(this, "toggle")
    })

    // if parent group checkbox get changed, so will children
    base.find(".grouped-checkbox-input").on("click",function(){
        // Select all children and change prop checked
        let element = $(this)
        element.siblings("ul").children().find(".grouped-checkbox-input").prop("checked", element.is(":checked"))

        // If not all children have the same check value, set parent to indeterminate.
        let checkStatus = [element.is(":checked")]
        element.parent().parent().siblings().children().children("input[type='checkbox']").each(function(){
            checkStatus.push($(this).is(":checked"))
        })

        
        let uniqueValues = [... new Set(checkStatus)]

        // Get parent checkbox which inderterminate needs too change.
        let parentCheckbox = element.parent().parent().parent().siblings(".grouped-checkbox-input")
        if (uniqueValues.length > 1){
            // Intermediate should be set as true
            parentCheckbox.prop({indeterminate: true, checked: false})
        } else {
            // Intermediate should be set to false. Value checked can be grabbed by getting the value from the element
            parentCheckbox.prop({indeterminate: false, checked: element.is(":checked")})
        }        
        setInput(id)
    })


    // Select all button
    base.find(".grouped-checkbox-select-all").on("click", function(){
        base.find(".grouped-checkbox-input").prop({indeterminate: false, checked: true})
        setInput(id)

    })

    // Deselect all
    base.find(".grouped-checkbox-deselect-all").on("click", function(){
        base.find(".grouped-checkbox-input").prop({indeterminate: false, checked: false})
        setInput(id)
    })

    // Expand all button
    base.find(".grouped-checkbox-expand-all").on("click", function(){
        console.log("Clicked expand all")
        base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxCaret).each(function(){
            let caret = $(this)
            if (caret.text() == "▶") {
                caret.text("▼")
                caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList).show()
                caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList).show()
            }
        })
    })
    

    // Collapse all button
    base.find(".grouped-checkbox-collapse-all").on("click", function(){
        base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxCaret).each(function(){
            let caret = $(this)
            if (caret.text() == "▼") {
                caret.text("▶")
                caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList).hide()
                caret.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList).hide()
            }
        })
    })

    // Include Exlude switch
    base.find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).on("click", function(){
        const allowedStates = ["INCLUDE", "EXCLUDE"]
        let btn = $(this)
        let currentState = btn.text()

        let newState = allowedStates[(allowedStates.indexOf(currentState) + 1) % allowedStates.length]

        // Set own state
        setBtnState(btn, newState)


        // Set state of all children
        btn.siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList).find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).each(function(){
            setBtnState($(this), newState)
        })

        // Check if the status of all the children are the same. If not set the parent status to "-"
        let checkStatus = [newState]
        btn.parent().parent().siblings().children().children("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).each(function(){
            checkStatus.push($(this).text())
        }
        )
        // If checkstatus is not the same, set the parent to "-"
        let uniqueValues = [... new Set(checkStatus)]
        if (uniqueValues.length > 1){
            btn.parent().parent().parent().siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).each(function(){
                setBtnState($(this), "-")
            })
        } else {
            btn.parent().parent().parent().siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude).each(function(){
                setBtnState($(this), newState)
            })
        }

        setInput(id)
        


    })

    // If label is clicked, check the checkbox and its children checkboxes
    base.find("." + "form-check-label").on("click", function(){
        let label = $(this)
        console.log("Label text: " + label.text())
        let checkbox = label.siblings(".grouped-checkbox-input")
        console.log("Checkbox: " + checkbox)
        
        // Click the checkbox so input is set
        checkbox.click()
    })

    //Set input
    setInput(id)
}



function updateCollapseButtonStatus(collapseButton, event=null){
    
    // Set text of collapse button to "Expand All" if event is "collapsed"
    let buttonText = collapseButton.text()
    
    if (event == "collapsed"){
        if (buttonText == "Expand All"){
            collapseButton.text("Collapse All")
        } else {
            collapseButton.text("Expand All")
        }
    } else if (event == "expanded"){
        if (buttonText == "Expand All"){
            collapseButton.text("Collapse All")
        } else {
            collapseButton.text("Expand All")
        }
    }


    
}
/**
 * > The function `parseTree` takes two arguments, `choices` and `levels`, and returns a new instance
 * of the `ConstructTree` class
 * @param choices - an Object with the data that will be used.
 * @param levels - the number of levels in the tree
 * @returns A ConstructTree object
 */
function parseTree(choices, levels){
    return new _constructTree__WEBPACK_IMPORTED_MODULE_1__.ConstructTree(choices, levels)
}

/**
 * > This function takes a tree Object and appends the nodes to the DOM
 * @param parent - the parent element to append the nodes to
 * @param tree - the tree object
 */
function appendNodes(parent, tree, includeMode) {
    console.log("Appending to parent: ")
    let base = $(parent)

    base.append($("<ul>", {"class": _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList, "id": "grouped-checkbox-list-base"}))


    let queue = []

    queue.push(tree.root)

    while (queue.length > 0) {
        let size = queue.length
        let current

        for (let i = 0; i < size; i++) {
            current = queue.shift()

            for (let child of current.children) {
                queue.push(child)
                if (child.parent.value === "root") {
                    child.htmlID = constructNode(child.value, null, child.has_children, base, includeMode)

                }
                else {
                    child.htmlID = /* Creating a new node with the name of the node being the first
                    argument and the value being the second argument. */
                    constructNode(child.value, child.parent, child.has_children, base, includeMode)
                }

            }
        }
    }
}


/**
 * It creates a new node, assigns it an ID, and appends it to the parent node
 * @param nodeName - The name of the node
 * @param nodeParent - The parent node of the node you're creating.
 * @param hasChildren - boolean
 * @returns The ID of the node that was just created.
 */
function constructNode(nodeName, nodeParent, hasChildren, base, include){
    // this function uses plain JS which increases the speed it takes to render the nodes by four times in comparison
    // with the more readable jquery    

    // Create a variable called parent containing the dom object which is the id 'grouped-checkbox-list-base'


    let parent;
    if (!nodeParent){
        parent = base.children($("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList))[0]
    } else {
        parent = base.find("#checkbox-list-" + nodeParent.htmlID)[0]
    }

    // Create ID for the nodes
    let nNodes = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.generateID)()
    let newNodeID = "node-" + nNodes

    let nodeListElement = document.createElement("li")


    // Create node and assign classes
    let node = document.createElement("span")
    node.classList.add("GroupedCheckBox-node", "text-fg")
    node.id = newNodeID


    if (hasChildren){
        node.appendChild((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.createCaret)())
    } 


    // Add the checkbox and label component
    node.appendChild((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.createInputCheckbox)(nodeName, nNodes))


    // If include is true, add include/exclude button
    if (include == true){
        let includeButton = document.createElement("button")
        includeButton.classList.add("btn", "btn-outline-success", "btn-sm", "mt-0", _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnInclude)
        includeButton.innerHTML = "INCLUDE"
        node.appendChild(includeButton)
    }



    node.appendChild((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.createCheckboxLabel)(nodeName, nNodes))
        

    if (hasChildren){
        let newList = document.createElement("ul")
        newList.classList.add(_tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxList)
        newList.id = "checkbox-list-" + newNodeID
        node.appendChild(newList)
    }

    nodeListElement.appendChild(node)
    parent.appendChild(nodeListElement)

    return newNodeID
}

// Check if btn state is valid and set right classes.
function setBtnState(btn, state){
    const allowedStates = ["INCLUDE", "EXCLUDE", "-"]
    if (!allowedStates.includes(state)){
        throw new Error("The state is not supported.")
    }

    btn.text(state)


    if (state == "INCLUDE"){
        btn.removeClass("btn-outline-danger")
        btn.removeClass(_tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnIndeterminate)
        btn.addClass("btn-outline-success")

    } else if (state == "EXCLUDE"){
        btn.removeClass("btn-outline-success")
        btn.removeClass(_tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnIndeterminate)
        btn.addClass("btn-outline-danger")

    }   else if (state == "-"){
        btn.removeClass("btn-outline-success")
        btn.removeClass("btn-outline-danger")
        btn.addClass(_tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].btnIndeterminate)
    }
}

/**
 * It takes a bunch of inputs, creates a tree, and then renders it
 * @param id - The id of the element that will hold the tree
 * @param label - The label for the tree
 * @param choices - A list of choices. Each choice is a list of length 2, where the first element is
 * the value of the choice, and the second element is the label.
 * @param levels - A vector of strings that indicate the levels of the tree.
 * @param collapsed - a boolean that determines whether the tree should be collapsed by default
 * @param selected - A vector of values that should be selected, If provided true.
 */
function createTree(id, label, choices, levels, collapsed, selected, includeMode) {

    let base = document.getElementById(id)



    // Create label
    if (label){
        let new_label = document.createElement("h4");
        new_label.innerText = label;
        base.appendChild(new_label)
    }

    // create select buttons
    $("#" + id).append((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.generateSelectButtons)())


    let tree = parseTree(choices, levels)

    // Create a container that holds the nodes
    let nodeContainer = document.createElement("div")
    nodeContainer.classList.add(_tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxNodeHolder)
    nodeContainer.classList.add("overflow-auto")
    nodeContainer.classList.add("align-self-center")
    base.appendChild(nodeContainer)


    // Render and append the nodes
    appendNodes(nodeContainer, tree, includeMode)



    // Hide the nodes
    if (typeof(collapsed) === "boolean" && collapsed){
        $("#" + id).find("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxCaret).each(function(){
            hideListElement(this, "toggle")
        })
    } else {
        if (typeof(collapsed) === "string"){
            collapsed = [collapsed]
        }
        for (let value of collapsed){
            let caret = $("#" + id).find("input[value='" + value + "']").siblings("." + _tree_css__WEBPACK_IMPORTED_MODULE_3__["default"].groupedCheckboxCaret);
            hideListElement(caret, "toggle")
        }
    }

    // Check which nodes should be selected
    if (typeof(selected) === "boolean" & selected === true){
        $("#" + id).find(".grouped-checkbox-input").prop({indeterminate: false, checked: true})}
    else{

        // If selected is a string put it into an array
        if (typeof(selected) === "string"){
            selected = [selected]
        }

        for (let value of selected){
            $("#" + id).find(".grouped-checkbox-input[value='" + value + "']").prop({indeterminate: false, checked: true})
        }
    }
    $(document).on("shiny:connected", function() {
        registerEvents(id)
    });

}




/***/ }),

/***/ "widgets":
/*!******************************!*\
  !*** external "HTMLWidgets" ***!
  \******************************/
/***/ ((module) => {

module.exports = HTMLWidgets;

/***/ }),

/***/ "shiny":
/*!************************!*\
  !*** external "Shiny" ***!
  \************************/
/***/ ((module) => {

module.exports = Shiny;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!***************************************!*\
  !*** ./srcjs/widgets/treecheckbox.js ***!
  \***************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! widgets */ "widgets");
/* harmony import */ var widgets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(widgets__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shiny */ "shiny");
/* harmony import */ var shiny__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(shiny__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _modules_renderTree_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/renderTree.js */ "./srcjs/modules/renderTree.js");





HTMLWidgets.widget({

  name: 'treecheckbox',

  type: 'output',

  factory: function(el, width, height) {

    // TODO: define shared variables for this instance

    return {

      renderValue: function(x) {

        (0,_modules_renderTree_js__WEBPACK_IMPORTED_MODULE_2__.createTree)(el.id, x.label, x.choices, x.levels, x.collapsed, x.selected, x.includeMode)

        // HTMLWidgets.widget sets a default size. Remove this default size and make auto.
        $("#" + el.id).css("height", "auto").css("width", "auto")
      },

      resize: function(width, height) {

        // TODO: code to re-render the widget with a new size

      }

    };
  }
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BOzs7Ozs7Ozs7Ozs7Ozs7O0FDQWlCO0FBQ0Y7O0FBRXFDOztBQUVwRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRLGtFQUFVOztBQUVsQjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vc3JjanMvbW9kdWxlcy90cmVlLmNzcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL3NyY2pzL21vZHVsZXMvdHJlZS5jc3M/OWNiMyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vc3JjanMvbW9kdWxlcy9jb25zdHJ1Y3RUcmVlLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vc3JjanMvbW9kdWxlcy9oZWxwZXJzLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94Ly4vc3JjanMvbW9kdWxlcy9yZW5kZXJUcmVlLmpzIiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94L2V4dGVybmFsIHZhciBcIkhUTUxXaWRnZXRzXCIiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvZXh0ZXJuYWwgdmFyIFwiU2hpbnlcIiIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc2hpbnl0cmVlY2hlY2tib3gvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3NoaW55dHJlZWNoZWNrYm94L3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9zaGlueXRyZWVjaGVja2JveC8uL3NyY2pzL3dpZGdldHMvdHJlZWNoZWNrYm94LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLyogU3R5bGUgdGhlIGNhcmV0L2Fycm93ICovXFxuLlVOd2t4ZXU4SmFMVVI3enNMT0xjIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7IC8qIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gKi9cXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1yaWdodDogNnB4O1xcbn1cXG5cXG4uZHBHOVZKQ2JFMVQzaHZOcVdBWFEge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG59XFxuXFxuLmZSRHBtSko5TVJYYW5FUmRsZ3VQIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2NjY2NjYztcXG4gIG1heC1oZWlnaHQ6IDI1dmg7XFxufVxcblxcbi5HbXRFTXVFMUJoQnVPSzRVRGVvSiB7XFxuICB3aWR0aDogMTZweDtcXG4gIGhlaWdodDogMTZweDtcXG4gIHBhZGRpbmc6IDFweDtcXG4gIG1hcmdpbi1sZWZ0OiAycHg7XFxuICBtYXJnaW4tcmlnaHQ6IDJweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGxpbmUtaGVpZ2h0OiAxNXB4O1xcbn1cXG5cXG4uR210RU11RTFCaEJ1T0s0VURlb0o6aG92ZXIge1xcbiAgd2lkdGg6IC13ZWJraXQtZml0LWNvbnRlbnQ7XFxuICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXG4gIHdpZHRoOiBmaXQtY29udGVudDtcXG4gIGhlaWdodDogLXdlYmtpdC1maXQtY29udGVudDtcXG4gIGhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XFxuICBtaW4td2lkdGg6IDE2cHg7XFxuICBtaW4taGVpZ2h0OiAxNnB4O1xcbn1cXG5cXG4ucUlQVnROb2RfaVFYcVBSNWdJdHcge1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYm9yZGVyLWNvbG9yOiBvcmFuZ2U7XFxuICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLXdpZHRoOiAxLjE3cHg7XFxuICBjb2xvcjogb3JhbmdlO1xcbn1cXG5cXG4ucUlQVnROb2RfaVFYcVBSNWdJdHc6aG92ZXIge1xcbiAgd2lkdGg6IDE2cHg7XFxuICBoZWlnaHQ6IDE2cHg7XFxuICBwYWRkaW5nOiAxcHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3JkZXItY29sb3I6IG9yYW5nZTtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItd2lkdGg6IDEuMTdweDtcXG4gIGNvbG9yOiBvcmFuZ2U7XFxufS8qIyBzb3VyY2VNYXBwaW5nVVJMPXRyZWUuY3NzLm1hcCAqL1wiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyY2pzL21vZHVsZXMvdHJlZS5zY3NzXCIsXCJ3ZWJwYWNrOi8vLi9zcmNqcy9tb2R1bGVzL3RyZWUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUNBLDBCQUFBO0FBQ0E7RUFDRSxlQUFBO0VBQ0EseUJBQUE7S0FBQSxzQkFBQTtNQUFBLHFCQUFBO1VBQUEsaUJBQUEsRUFBQSwyQkFBQTtFQUNBLHFCQUFBO0VBQ0EsaUJBQUE7QUNBRjs7QURHQTtFQUNFLGdCQUFBO0FDQUY7O0FER0E7RUFDRSx1QkFBQTtFQUNBLGtCQUFBO0VBQ0EseUJBQUE7RUFDQSxnQkFBQTtBQ0FGOztBRElBO0VBQ0UsV0FBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EscUJBQUE7RUFDQSxpQkFBQTtBQ0RGOztBRElBO0VBQ0UsMEJBQUE7RUFBQSx1QkFBQTtFQUFBLGtCQUFBO0VBQ0EsMkJBQUE7RUFBQSx3QkFBQTtFQUFBLG1CQUFBO0VBRUEsZUFBQTtFQUNBLGdCQUFBO0FDRkY7O0FES0E7RUFDRSxrQkFBQTtFQUNBLG9CQUFBO0VBQ0EsbUJBQUE7RUFDQSxvQkFBQTtFQUNBLGFBQUE7QUNGRjs7QURLQTtFQUNFLFdBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtFQUNBLGtCQUFBO0VBQ0Esb0JBQUE7RUFDQSxtQkFBQTtFQUNBLG9CQUFBO0VBQ0EsYUFBQTtBQ0ZGLENBQUEsbUNBQUFcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImdyb3VwZWRDaGVja2JveENhcmV0XCI6IFwiVU53a3hldThKYUxVUjd6c0xPTGNcIixcblx0XCJncm91cGVkQ2hlY2tib3hMaXN0XCI6IFwiZHBHOVZKQ2JFMVQzaHZOcVdBWFFcIixcblx0XCJncm91cGVkQ2hlY2tib3hOb2RlSG9sZGVyXCI6IFwiZlJEcG1KSjlNUlhhbkVSZGxndVBcIixcblx0XCJidG5JbmNsdWRlXCI6IFwiR210RU11RTFCaEJ1T0s0VURlb0pcIixcblx0XCJidG5JbmRldGVybWluYXRlXCI6IFwicUlQVnROb2RfaVFYcVBSNWdJdHdcIlxufTtcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07IiwiXG4gICAgICBpbXBvcnQgQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICBpbXBvcnQgZG9tQVBJIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRGbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanNcIjtcbiAgICAgIGltcG9ydCBzZXRBdHRyaWJ1dGVzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0U3R5bGVFbGVtZW50IGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzXCI7XG4gICAgICBpbXBvcnQgc3R5bGVUYWdUcmFuc2Zvcm1GbiBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzXCI7XG4gICAgICBpbXBvcnQgY29udGVudCwgKiBhcyBuYW1lZEV4cG9ydCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1swXS51c2VbMV0hLi90cmVlLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xuXG4gICAgICBvcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xuICAgIFxub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzBdLnVzZVsxXSEuL3RyZWUuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcblxuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG5cbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG5cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG5cbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG5cbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG5cbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG5cbiAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcyhzdHlsZUVsZW1lbnQpIHtcbiAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KG9iai5zdXBwb3J0cywgXCIpIHtcIik7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cblxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICBpZiAobmVlZExheWVyKSB7XG4gICAgY3NzICs9IFwiQGxheWVyXCIuY29uY2F0KG9iai5sYXllci5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KG9iai5sYXllcikgOiBcIlwiLCBcIiB7XCIpO1xuICB9XG5cbiAgY3NzICs9IG9iai5jc3M7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGVFbGVtZW50LnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9tQVBJOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIHN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50KSB7XG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIlxuXG4vKiBUaGUgQ29uc3RydWN0VHJlZSBjbGFzcyB0YWtlcyBpbiBhIGxpc3Qgb2YgcmVjb3JkcyBhbmQgYSBsaXN0IG9mIGxldmVscywgYW5kIGJ1aWxkcyBhIHRyZWUgb2Ygbm9kZXNcbndoZXJlIGVhY2ggbm9kZSByZXByZXNlbnRzIGEgbGV2ZWwgYW5kIGVhY2ggbm9kZSdzIGNoaWxkcmVuIHJlcHJlc2VudCB0aGUgbmV4dCBsZXZlbCAqL1xuY2xhc3MgQ29uc3RydWN0VHJlZSB7XG4gICAgcm9vdFxuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGxldmVscykge1xuICAgICAgICB0aGlzLmJ1aWxkVHJlZShkYXRhLCBsZXZlbHMpXG4gICAgfVxuXG5cbi8qKlxuICogPiBUaGUgZnVuY3Rpb24gdGFrZXMgaW4gYSBkYXRhIHNldCBhbmQgYSBsaXN0IG9mIGxldmVscywgYW5kIGJ1aWxkcyBhIHRyZWUgd2l0aCB0aGUgZGF0YSBzZXRcbiAqIEBwYXJhbSBkYXRhIC0gdGhlIGRhdGEgeW91IHdhbnQgdG8gYnVpbGQgdGhlIHRyZWUgZnJvbVxuICogQHBhcmFtIGxldmVscyAtIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgdGhlIGxldmVscyBvZiB0aGUgdHJlZS5cbiAqL1xuICAgIGJ1aWxkVHJlZShkYXRhLCBsZXZlbHMpe1xuICAgICAgICBsZXQgcm9vdCA9IG5ldyBOb2RlKFwicm9vdFwiKVxuICAgICAgICBsZXQgbmV3RGF0YVxuXG4gICAgICAgIGRhdGEuZm9yRWFjaChyZWNvcmQgPT4ge1xuICAgICAgICAgICAgbmV3RGF0YSA9IFtdXG4gICAgICAgICAgICBsZXZlbHMuZm9yRWFjaChsZXZlbCA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YS5wdXNoKHJlY29yZFtsZXZlbF0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdGhpcy4jZmluZE9yQXBwZW5kKHJvb3QsIG5ld0RhdGEpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICB9XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4IGRlcHRoIG9mIHRoZSB0cmVlXG4gKiBAcmV0dXJucyBUaGUgZGVwdGggb2YgdGhlIHRyZWVcbiAqL1xuICAgIGZpbmRNYXhEZXB0aCgpe1xuICAgICAgICBsZXQgcXVldWUgPSBbXVxuICAgICAgICBsZXQgZGVwdGggPSAwXG5cbiAgICAgICAgcXVldWUucHVzaCh0aGlzLnJvb3QpXG5cbiAgICAgICAgd2hpbGUocXVldWUubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHF1ZXVlLmxlbmd0aFxuXG4gICAgICAgICAgICBsZXQgY3VycmVudFxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemUgOyBpKyspe1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpXG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjdXJyZW50LmNoaWxkcmVuKXtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChjaGlsZClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXB0aCArK1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aCAtIDFcbiAgICB9XG5cbi8qKlxuICogPiBHaXZlbiBhIHRyZWUgYW5kIGEgbGlzdCBvZiB2YWx1ZXMsIGZpbmQgdGhlIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYXRjaGVzIHRoZSBsYXN0IHZhbHVlIGluIHRoZVxuICogbGlzdCwgYW5kIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBpdFxuICogQHBhcmFtIHRyZWUgLSB0aGUgdHJlZSB0byBzZWFyY2hcbiAqIEBwYXJhbSB2YWx1ZXMgLSBhbiBhcnJheSBvZiB2YWx1ZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHRyZWVcbiAqIEByZXR1cm5zIFRoZSB0cmVlIHdpdGggdGhlIG5ldyB2YWx1ZXMgYWRkZWQuXG4gKi9cbiAgICAjZmluZE9yQXBwZW5kKHRyZWUsIHZhbHVlcyl7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aCA7IGkrKyl7XG4gICAgICAgICAgICBsZXQga2V5UXVldWUgPSB2YWx1ZXMuc2xpY2UoMCwgaSArIDEpXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV1cbiAgICAgICAgICAgIGxldCBbbm9kZUluLCBfXSA9IHRoaXMuI3JlY3Vyc2l2ZVNlYXJjaCh0cmVlLCBrZXlRdWV1ZSlcbiAgICAgICAgICAgIGlmIChub2RlSW4udmFsdWUgIT09IHZhbHVlKXtcbiAgICAgICAgICAgICAgICBsZXQgbmV3Tm9kZSA9IG5ldyBOb2RlKHZhbHVlKVxuICAgICAgICAgICAgICAgIG5vZGVJbi5hZGRfY2hpbGQobmV3Tm9kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4odHJlZSlcbiAgICB9XG4gICAgXG4vKipcbiAqID4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSBhbmQgYSBsaXN0IG9mIHZhbHVlcyB0byBmaW5kLiBJdCByZXR1cm5zIHRoZSBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgbGFzdFxuICogdmFsdWUgaW4gdGhlIGxpc3QsIGFuZCB0aGUgbGlzdCBvZiB2YWx1ZXMgdGhhdCB3ZXJlIG5vdCBmb3VuZFxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0aGF0IHdlIGFyZSBjdXJyZW50bHkgc2VhcmNoaW5nXG4gKiBAcGFyYW0gZmluZCAtIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnQgdGhlIHBhdGggdG8gdGhlIG5vZGUgeW91IHdhbnQgdG8gZmluZFxuICogQHJldHVybnMgVGhlIG5vZGUgdGhhdCBpcyB0aGUgbGFzdCBpbiB0aGUgcGF0aCwgYW5kIHRoZSBwYXRoIHRoYXQgaXMgbGVmdCB0byBiZSBzZWFyY2hlZC5cbiAqL1xuICAgICNyZWN1cnNpdmVTZWFyY2gobm9kZSwgZmluZCl7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW5cbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGZpbmRpbmcgPSBmaW5kWzBdXG4gICAgICAgICAgICBpZiAoZmluZGluZyA9PT0gY2hpbGQudmFsdWUpe1xuICAgICAgICAgICAgICAgIGZpbmQuc2hpZnQoKVxuICAgICAgICAgICAgICAgIGlmIChmaW5kLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVjdXJzaXZlU2VhcmNoKGNoaWxkLCBmaW5kKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybihbY2hpbGQsIGZpbmRdKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vZGUsIGZpbmRdXG4gICAgfVxuXG5cbn1cblxuXG4vKiBBIG5vZGUgaXMgYSB2YWx1ZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgYSBwYXJlbnQgKi9cbmNsYXNzIE5vZGV7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFjaGlsZHJlbil7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlblxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFxuICAgICAgICB0aGlzLmRlcHRoID0gMFxuICAgIH1cblxuICAgIC8qXG4gICAgICogQWRkIGNoaWxkcmVuIHRvIG5vZGUsIGFuZCByZWdpc3RlciBwYXJlbnQgaW4gY2hpbGQuXG4gICAgICovXG4gICAgYWRkX2NoaWxkKGNoaWxkKXtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgY2hpbGQuYWRkUGFyZW50KHRoaXMpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkUGFyZW50KHBhcmVudCl7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQuZGVwdGggKyAxXG4gICAgfVxuXG4gICAgZ2V0IGhhc19jaGlsZHJlbigpe1xuICAgICAgICByZXR1cm4oKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkpXG4gICAgfVxuXG4gICAgZ2V0IHNpYmxpbmdzKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZHJlblxuICAgIH1cblxuICAgIGZpbmRPYmplY3RCeU5hbWUobmFtZSl7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBuYW1lKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pe1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGNoaWxkLmZpbmRPYmplY3RCeU5hbWUobmFtZSlcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IHtDb25zdHJ1Y3RUcmVlfSIsImltcG9ydCBzdHlsZXMgZnJvbSAnLi90cmVlLmNzcydcblxuLyogQSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gKi9cbmxldCBnZW5lcmF0ZUlEID0gKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG4gKz0gMVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG59KC0xKSlcblxuXG4vKipcbiAqIEl0IGNyZWF0ZXMgYSBzcGFuIGVsZW1lbnQsIGFkZHMgdGhlIGNsYXNzIGBncm91cGVkQ2hlY2tib3hDYXJldGAgdG8gaXQsIGFuZCBzZXRzIGl0cyBpbm5lciB0ZXh0IHRvXG4gKiBcIuKWvFwiLlxuICogQHJldHVybnMgQSBzcGFuIGVsZW1lbnQgd2l0aCB0aGUgY2xhc3MgXCJncm91cGVkQ2hlY2tib3hDYXJldFwiIGFuZCB0aGUgaW5uZXIgdGV4dCBcIuKWvFwiXG4gKi9cbiBmdW5jdGlvbiBjcmVhdGVDYXJldCgpe1xuICAgIGxldCBjYXJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgY2FyZXQuY2xhc3NMaXN0LmFkZChzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpXG4gICAgY2FyZXQuaW5uZXJUZXh0ID0gXCLilrxcIlxuICAgIHJldHVybihjYXJldClcbn1cblxuXG4vKipcbiAqIEl0IGNyZWF0ZXMgYSBjaGVja2JveCBpbnB1dCBlbGVtZW50XG4gKiBAcGFyYW0gbm9kZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbm9kZVxuICogQHBhcmFtIG5vZGVJRCAtIFRoZSBJRCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dENoZWNrYm94IGVsZW1lbnRcbiAqL1xuIGZ1bmN0aW9uIGNyZWF0ZUlucHV0Q2hlY2tib3gobm9kZU5hbWUsIG5vZGVJRCkge1xuICAgIGxldCBpbnB1dENoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpXG4gICAgaW5wdXRDaGVja2JveC5jbGFzc0xpc3QuYWRkKFwiZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiLCBcImZvcm0tY2hlY2staW5wdXRcIilcbiAgICBpbnB1dENoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCJcbiAgICBpbnB1dENoZWNrYm94LnZhbHVlID0gbm9kZU5hbWVcbiAgICBpbnB1dENoZWNrYm94LmlkID0gXCJub2RlLWlucHV0LWNoZWNrXCIgKyBub2RlSURcbiAgICByZXR1cm4oaW5wdXRDaGVja2JveClcbn1cblxuLyoqXG4gKiBJdCBjcmVhdGVzIGEgbGFiZWwgZm9yIGEgY2hlY2tib3hcbiAqIEBwYXJhbSBub2RlTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gaWQgLSB0aGUgaWQgb2YgdGhlIG5vZGVcbiAqIEByZXR1cm5zIEEgbGFiZWwgZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGVja2JveExhYmVsKG5vZGVOYW1lLCBpZCl7XG4gICAgbGV0IGxhYmVsQ2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIilcbiAgICBsYWJlbENoZWNrYm94LmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNoZWNrLWxhYmVsXCIpXG4gICAgbGFiZWxDaGVja2JveC5mb3IgPSBcIm5vZGUtaW5wdXQtY2hlY2tcIiArIGlkXG4gICAgbGFiZWxDaGVja2JveC5pbm5lckhUTUwgPSBub2RlTmFtZVxuICAgIHJldHVybihsYWJlbENoZWNrYm94KVxufVxuXG4vKipcbiAqIEl0IGdlbmVyYXRlcyBhIGNvbnRhaW5lciB3aXRoIHR3byBidXR0b25zLCBvbmUgdG8gc2VsZWN0IGFsbCBjaGVja2JveGVzIGFuZCBvbmUgdG8gZGVzZWxlY3QgYWxsXG4gKiBjaGVja2JveGVzXG4gKiBAcmV0dXJucyBBIGRpdiB3aXRoIHR3byBidXR0b25zLlxuICovXG4gZnVuY3Rpb24gZ2VuZXJhdGVTZWxlY3RCdXR0b25zKCl7XG4gICAgbGV0IGNvbnRhaW5lciA9ICQoXCI8ZGl2PlwiLCB7XCJjbGFzc1wiOiBcImQtZmxleCBqdXN0aWZ5LWNvbnRlbnQtZXZlbmx5XCJ9KVxuICAgIGNvbnRhaW5lci5hcHBlbmQoJChcIjxidXR0b24+XCIsIHtcImNsYXNzXCI6IFwiZmxleC1jaGlsZCBncm91cGVkLWNoZWNrYm94LXNlbGVjdC1hbGwgYnRuIGJ0bi1vdXRsaW5lLWZnXCIsXG4gICAgICAgIFwiaWRcIjogXCJncm91cGVkLWNoZWNrYm94LXNlbGVjdC1hbGwtXCIgKyBnZW5lcmF0ZUlEKCksIFwiY3NzXCI6IHtcImZvbnQtc2l6ZVwiOiBcIngtc21hbGxcIn19KS50ZXh0KFwiU2VsZWN0IEFsbFwiKSlcbiAgICBjb250YWluZXIuYXBwZW5kKCQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImZsZXgtY2hpbGQgZ3JvdXBlZC1jaGVja2JveC1kZXNlbGVjdC1hbGwgYnRuIGJ0bi1vdXRsaW5lLWZnXCIsXG4gICAgICAgIFwiaWRcIjogXCJncm91cGVkLWNoZWNrYm94LWRlc2VsZWN0LWFsbC1cIiArIGdlbmVyYXRlSUQoKSwgXCJjc3NcIjoge1wiZm9udC1zaXplXCI6IFwieC1zbWFsbFwifX0pLnRleHQoXCJEZXNlbGVjdCBBbGxcIikpXG5cbiAgICBjb250YWluZXIuYXBwZW5kKCQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImZsZXgtY2hpbGQgZ3JvdXBlZC1jaGVja2JveC1leHBhbmQtYWxsIGJ0biBidG4tb3V0bGluZS1mZ1wiLCBcbiAgICBcImlkXCI6IFwiZ3JvdXBlZC1jaGVja2JveC1leHBhbmQtYWxsLVwiICsgZ2VuZXJhdGVJRCgpLCBcImNzc1wiOiB7XCJmb250LXNpemVcIjogXCJ4LXNtYWxsXCJ9fSkudGV4dChcIkV4cGFuZCBBbGxcIikpXG5cbiAgICBjb250YWluZXIuYXBwZW5kKCQoXCI8YnV0dG9uPlwiLCB7XCJjbGFzc1wiOiBcImZsZXgtY2hpbGQgZ3JvdXBlZC1jaGVja2JveC1jb2xsYXBzZS1hbGwgYnRuIGJ0bi1vdXRsaW5lLWZnXCIsIFxuICAgIFwiaWRcIjogXCJncm91cGVkLWNoZWNrYm94LWNvbGxhcHNlLWFsbC1cIiArIGdlbmVyYXRlSUQoKSwgXCJjc3NcIjoge1wiZm9udC1zaXplXCI6IFwieC1zbWFsbFwifX0pLnRleHQoXCJDb2xsYXBzZSBBbGxcIikpXG4gICBcbiAgICByZXR1cm4oY29udGFpbmVyKVxufVxuXG5leHBvcnQge2NyZWF0ZUNhcmV0LCBjcmVhdGVJbnB1dENoZWNrYm94LCBjcmVhdGVDaGVja2JveExhYmVsLCBnZW5lcmF0ZVNlbGVjdEJ1dHRvbnMsIGdlbmVyYXRlSUR9IiwiaW1wb3J0ICdzaGlueSc7XG5pbXBvcnQge0NvbnN0cnVjdFRyZWV9IGZyb20gXCIuL2NvbnN0cnVjdFRyZWVcIjtcbmltcG9ydCB7IGdlbmVyYXRlSUQsIGNyZWF0ZUNhcmV0LCBjcmVhdGVJbnB1dENoZWNrYm94LCBjcmVhdGVDaGVja2JveExhYmVsLCBnZW5lcmF0ZVNlbGVjdEJ1dHRvbnMgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3RyZWUuY3NzJ1xuXG4vKipcbiAqIEl0IHRha2VzIGFuIGVsZW1lbnQgYW5kIGFuIGFuaW1hdGlvbiB0eXBlLCBhbmQgdG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZWxlbWVudCdzIHNpYmxpbmdzXG4gKiBAcGFyYW0gZWxlbWVudCAtIHRoZSBlbGVtZW50IHRoYXQgaXMgY2xpY2tlZCB0byBoaWRlL3Nob3dcbiAqIEBwYXJhbSBhbmltYXRpb24gLSBcInRvZ2dsZVwiIG9yIFwic2xpZGVcIlxuICovXG5mdW5jdGlvbiBoaWRlTGlzdEVsZW1lbnQoZWxlbWVudCwgYW5pbWF0aW9uPVwidG9nZ2xlXCIpe1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB7XCJ0b2dnbGVcIjoge1wic2hvd1wiOiBcInNob3dcIiwgXCJoaWRlXCI6IFwiaGlkZVwifSwgXCJzbGlkZVwiOiB7XCJzaG93XCI6IFwic2xpZGVEb3duXCIsIFwiaGlkZVwiOiBcInNsaWRlVXBcIn19XG5cbiAgICBsZXQgY2FyZXQgPSAkKGVsZW1lbnQpXG4gICAgaWYgKCEoYW5pbWF0aW9uIGluIGFuaW1hdGlvbnMpKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFuaW1hdGlvbiB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXCIpXG5cbiAgICB9XG5cbiAgICBsZXQgY29sbGFwc2VkU3RhdHVzXG4gICAgaWYgKGNhcmV0LnRleHQoKSA9PSBcIuKWvFwiKSB7XG4gICAgICAgIGNhcmV0LnRleHQoXCLilrZcIilcbiAgICAgICAgY2FyZXQuc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94TGlzdClbYW5pbWF0aW9uc1thbmltYXRpb25dW1wiaGlkZVwiXV0oKVxuICAgICAgICBjb2xsYXBzZWRTdGF0dXMgPSBcImNvbGxhcHNlZFwiXG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FyZXQudGV4dChcIuKWvFwiKVxuICAgICAgICBjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KVthbmltYXRpb25zW2FuaW1hdGlvbl1bXCJzaG93XCJdXSgpXG4gICAgICAgIGNvbGxhcHNlZFN0YXR1cyA9IFwiZXhwYW5kZWRcIlxuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSXQgdGFrZXMgdGhlIGlkIG9mIGEgY2hlY2tib3hHcm91cElucHV0LCBmaW5kcyBhbGwgdGhlIGNoZWNrYm94ZXMgdGhhdCBhcmUgY2hlY2tlZCwgYW5kIHRoZW4gc2V0c1xuICogdGhlIFNoaW55IGlucHV0IHRvIHRoZSB2YWx1ZXMgb2YgdGhlIGNoZWNrZWQgY2hlY2tib3hlc1xuICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBjaGVja2JveEdyb3VwSW5wdXRcbiAqL1xuZnVuY3Rpb24gc2V0SW5wdXQoaWQpe1xuICAgIFxuICAgIC8vIENoZWNrIGlmIGVsZW1lbnQgd2l0aCBpZCAnaWQnIGhhcyBjaGlsZHJlbiB3aXRoIHRoZSBidXR0b24gY2xhc3MgJ3N0eWxlcy5idG5JbmNsdWRlJ1xuXG4gICAgLy8gQ2hlY2tzIGlmIG1vZGUgaXMgXCJpbmNsdWRlXCIgYnkgZmluZGluZyB0aGUgYnV0dG9uIHdpdGggdGhlIGNsYXNzIFwic3R5bGVzLmJ0bkluY2x1ZGVcbiAgICBsZXQgaW5jbHVkZU1vZGUgPSAkKFwiI1wiICsgaWQpLmZpbmQoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkubGVuZ3RoID4gMFxuXG4gICAgbGV0IHNlbGVjdGVkXG4gICAgaWYgKGluY2x1ZGVNb2RlKXtcbiAgICAgICAgc2VsZWN0ZWQgPSB7XCJpbmNsdWRlZFwiOiBbXSwgXCJleGNsdWRlZFwiOiBbXX1cbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9IFtdXG4gICAgfVxuXG5cblxuICAgICQoXCIjXCIgKyBpZCkuZmluZChcImlucHV0OmNoZWNrYm94OmNoZWNrZWRcIikuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICBsZXQgY2hlY2tib3ggPSAkKHRoaXMpXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNoZWNrYm94IGhhcyBjaGlsZHJlbiBhcyB3ZSBvbmx5IG5lZWQgYXR0cmlidXRlIG5hbWVzXG4gICAgICAgIGlmIChjaGVja2JveC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KS5sZW5ndGggPT09IDApe1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVNb2RlKXtcblxuICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIG1vZGUgcmV0dXJucyB0d28gbGlzdHMsIG9uZSB3aXRoIHRoZSBpbmNsdWRlZCBhdHRyaWJ1dGVzIGFuZCBvbmUgd2l0aCB0aGUgZXhjbHVkZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGxldCBzdGF0ZSA9IGNoZWNrYm94LnNpYmxpbmdzKFwiLlwiICsgc3R5bGVzLmJ0bkluY2x1ZGUpLnRleHQoKVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PSBcIklOQ0xVREVcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFtcImluY2x1ZGVkXCJdLnB1c2goY2hlY2tib3gudmFsKCkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRbXCJleGNsdWRlZFwiXS5wdXNoKGNoZWNrYm94LnZhbCgpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm9ybWFsIG1vZGUgcmV0dXJucyBhIHNpbmdsZSBsaXN0IHdpdGggdGhlIGluY2x1ZGVkIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKGNoZWNrYm94LnZhbCgpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgICAgIFxuICAgIC8vIFNldCBvdXRwdXRcbiAgICBTaGlueS5zZXRJbnB1dFZhbHVlKGlkLCBzZWxlY3RlZCwge3ByaW9yaXR5OiBcImV2ZW50XCJ9KTtcblxufVxuXG4vKiBSZWdpc3RlcmluZyBldmVudHMgZm9yIHRoZSBjaGVja2JveGVzLiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoaWQpe1xuXG4gICAgbGV0IGJhc2UgPSAkKFwiI1wiICsgaWQpXG5cbiAgICAvLyBIaWRlIGlmIGNhcmV0IGlzIGNsaWNrZWRcbiAgICBiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCl7XG4gICAgICAgIGhpZGVMaXN0RWxlbWVudCh0aGlzLCBcInRvZ2dsZVwiKVxuICAgIH0pXG5cbiAgICAvLyBpZiBwYXJlbnQgZ3JvdXAgY2hlY2tib3ggZ2V0IGNoYW5nZWQsIHNvIHdpbGwgY2hpbGRyZW5cbiAgICBiYXNlLmZpbmQoXCIuZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gU2VsZWN0IGFsbCBjaGlsZHJlbiBhbmQgY2hhbmdlIHByb3AgY2hlY2tlZFxuICAgICAgICBsZXQgZWxlbWVudCA9ICQodGhpcylcbiAgICAgICAgZWxlbWVudC5zaWJsaW5ncyhcInVsXCIpLmNoaWxkcmVuKCkuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWlucHV0XCIpLnByb3AoXCJjaGVja2VkXCIsIGVsZW1lbnQuaXMoXCI6Y2hlY2tlZFwiKSlcblxuICAgICAgICAvLyBJZiBub3QgYWxsIGNoaWxkcmVuIGhhdmUgdGhlIHNhbWUgY2hlY2sgdmFsdWUsIHNldCBwYXJlbnQgdG8gaW5kZXRlcm1pbmF0ZS5cbiAgICAgICAgbGV0IGNoZWNrU3RhdHVzID0gW2VsZW1lbnQuaXMoXCI6Y2hlY2tlZFwiKV1cbiAgICAgICAgZWxlbWVudC5wYXJlbnQoKS5wYXJlbnQoKS5zaWJsaW5ncygpLmNoaWxkcmVuKCkuY2hpbGRyZW4oXCJpbnB1dFt0eXBlPSdjaGVja2JveCddXCIpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNoZWNrU3RhdHVzLnB1c2goJCh0aGlzKS5pcyhcIjpjaGVja2VkXCIpKVxuICAgICAgICB9KVxuXG4gICAgICAgIFxuICAgICAgICBsZXQgdW5pcXVlVmFsdWVzID0gWy4uLiBuZXcgU2V0KGNoZWNrU3RhdHVzKV1cblxuICAgICAgICAvLyBHZXQgcGFyZW50IGNoZWNrYm94IHdoaWNoIGluZGVydGVybWluYXRlIG5lZWRzIHRvbyBjaGFuZ2UuXG4gICAgICAgIGxldCBwYXJlbnRDaGVja2JveCA9IGVsZW1lbnQucGFyZW50KCkucGFyZW50KCkucGFyZW50KCkuc2libGluZ3MoXCIuZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiKVxuICAgICAgICBpZiAodW5pcXVlVmFsdWVzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHNob3VsZCBiZSBzZXQgYXMgdHJ1ZVxuICAgICAgICAgICAgcGFyZW50Q2hlY2tib3gucHJvcCh7aW5kZXRlcm1pbmF0ZTogdHJ1ZSwgY2hlY2tlZDogZmFsc2V9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIHNob3VsZCBiZSBzZXQgdG8gZmFsc2UuIFZhbHVlIGNoZWNrZWQgY2FuIGJlIGdyYWJiZWQgYnkgZ2V0dGluZyB0aGUgdmFsdWUgZnJvbSB0aGUgZWxlbWVudFxuICAgICAgICAgICAgcGFyZW50Q2hlY2tib3gucHJvcCh7aW5kZXRlcm1pbmF0ZTogZmFsc2UsIGNoZWNrZWQ6IGVsZW1lbnQuaXMoXCI6Y2hlY2tlZFwiKX0pXG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBzZXRJbnB1dChpZClcbiAgICB9KVxuXG5cbiAgICAvLyBTZWxlY3QgYWxsIGJ1dHRvblxuICAgIGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LXNlbGVjdC1hbGxcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICBiYXNlLmZpbmQoXCIuZ3JvdXBlZC1jaGVja2JveC1pbnB1dFwiKS5wcm9wKHtpbmRldGVybWluYXRlOiBmYWxzZSwgY2hlY2tlZDogdHJ1ZX0pXG4gICAgICAgIHNldElucHV0KGlkKVxuXG4gICAgfSlcblxuICAgIC8vIERlc2VsZWN0IGFsbFxuICAgIGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWRlc2VsZWN0LWFsbFwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWlucHV0XCIpLnByb3Aoe2luZGV0ZXJtaW5hdGU6IGZhbHNlLCBjaGVja2VkOiBmYWxzZX0pXG4gICAgICAgIHNldElucHV0KGlkKVxuICAgIH0pXG5cbiAgICAvLyBFeHBhbmQgYWxsIGJ1dHRvblxuICAgIGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWV4cGFuZC1hbGxcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNsaWNrZWQgZXhwYW5kIGFsbFwiKVxuICAgICAgICBiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94Q2FyZXQpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCBjYXJldCA9ICQodGhpcylcbiAgICAgICAgICAgIGlmIChjYXJldC50ZXh0KCkgPT0gXCLilrZcIikge1xuICAgICAgICAgICAgICAgIGNhcmV0LnRleHQoXCLilrxcIilcbiAgICAgICAgICAgICAgICBjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KS5zaG93KClcbiAgICAgICAgICAgICAgICBjYXJldC5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hMaXN0KS5zaG93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KVxuICAgIFxuXG4gICAgLy8gQ29sbGFwc2UgYWxsIGJ1dHRvblxuICAgIGJhc2UuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWNvbGxhcHNlLWFsbFwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGJhc2UuZmluZChcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hDYXJldCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgbGV0IGNhcmV0ID0gJCh0aGlzKVxuICAgICAgICAgICAgaWYgKGNhcmV0LnRleHQoKSA9PSBcIuKWvFwiKSB7XG4gICAgICAgICAgICAgICAgY2FyZXQudGV4dChcIuKWtlwiKVxuICAgICAgICAgICAgICAgIGNhcmV0LnNpYmxpbmdzKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpLmhpZGUoKVxuICAgICAgICAgICAgICAgIGNhcmV0LnNpYmxpbmdzKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpLmhpZGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pXG5cbiAgICAvLyBJbmNsdWRlIEV4bHVkZSBzd2l0Y2hcbiAgICBiYXNlLmZpbmQoXCIuXCIgKyBzdHlsZXMuYnRuSW5jbHVkZSkub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAgICAgICBjb25zdCBhbGxvd2VkU3RhdGVzID0gW1wiSU5DTFVERVwiLCBcIkVYQ0xVREVcIl1cbiAgICAgICAgbGV0IGJ0biA9ICQodGhpcylcbiAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGJ0bi50ZXh0KClcblxuICAgICAgICBsZXQgbmV3U3RhdGUgPSBhbGxvd2VkU3RhdGVzWyhhbGxvd2VkU3RhdGVzLmluZGV4T2YoY3VycmVudFN0YXRlKSArIDEpICUgYWxsb3dlZFN0YXRlcy5sZW5ndGhdXG5cbiAgICAgICAgLy8gU2V0IG93biBzdGF0ZVxuICAgICAgICBzZXRCdG5TdGF0ZShidG4sIG5ld1N0YXRlKVxuXG5cbiAgICAgICAgLy8gU2V0IHN0YXRlIG9mIGFsbCBjaGlsZHJlblxuICAgICAgICBidG4uc2libGluZ3MoXCIuXCIgKyBzdHlsZXMuZ3JvdXBlZENoZWNrYm94TGlzdCkuZmluZChcIi5cIiArIHN0eWxlcy5idG5JbmNsdWRlKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZXRCdG5TdGF0ZSgkKHRoaXMpLCBuZXdTdGF0ZSlcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3RhdHVzIG9mIGFsbCB0aGUgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLiBJZiBub3Qgc2V0IHRoZSBwYXJlbnQgc3RhdHVzIHRvIFwiLVwiXG4gICAgICAgIGxldCBjaGVja1N0YXR1cyA9IFtuZXdTdGF0ZV1cbiAgICAgICAgYnRuLnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKCkuY2hpbGRyZW4oKS5jaGlsZHJlbihcIi5cIiArIHN0eWxlcy5idG5JbmNsdWRlKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjaGVja1N0YXR1cy5wdXNoKCQodGhpcykudGV4dCgpKVxuICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgLy8gSWYgY2hlY2tzdGF0dXMgaXMgbm90IHRoZSBzYW1lLCBzZXQgdGhlIHBhcmVudCB0byBcIi1cIlxuICAgICAgICBsZXQgdW5pcXVlVmFsdWVzID0gWy4uLiBuZXcgU2V0KGNoZWNrU3RhdHVzKV1cbiAgICAgICAgaWYgKHVuaXF1ZVZhbHVlcy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgIGJ0bi5wYXJlbnQoKS5wYXJlbnQoKS5wYXJlbnQoKS5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5idG5JbmNsdWRlKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgc2V0QnRuU3RhdGUoJCh0aGlzKSwgXCItXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnRuLnBhcmVudCgpLnBhcmVudCgpLnBhcmVudCgpLnNpYmxpbmdzKFwiLlwiICsgc3R5bGVzLmJ0bkluY2x1ZGUpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBzZXRCdG5TdGF0ZSgkKHRoaXMpLCBuZXdTdGF0ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbnB1dChpZClcbiAgICAgICAgXG5cblxuICAgIH0pXG5cbiAgICAvLyBJZiBsYWJlbCBpcyBjbGlja2VkLCBjaGVjayB0aGUgY2hlY2tib3ggYW5kIGl0cyBjaGlsZHJlbiBjaGVja2JveGVzXG4gICAgYmFzZS5maW5kKFwiLlwiICsgXCJmb3JtLWNoZWNrLWxhYmVsXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgbGV0IGxhYmVsID0gJCh0aGlzKVxuICAgICAgICBjb25zb2xlLmxvZyhcIkxhYmVsIHRleHQ6IFwiICsgbGFiZWwudGV4dCgpKVxuICAgICAgICBsZXQgY2hlY2tib3ggPSBsYWJlbC5zaWJsaW5ncyhcIi5ncm91cGVkLWNoZWNrYm94LWlucHV0XCIpXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2hlY2tib3g6IFwiICsgY2hlY2tib3gpXG4gICAgICAgIFxuICAgICAgICAvLyBDbGljayB0aGUgY2hlY2tib3ggc28gaW5wdXQgaXMgc2V0XG4gICAgICAgIGNoZWNrYm94LmNsaWNrKClcbiAgICB9KVxuXG4gICAgLy9TZXQgaW5wdXRcbiAgICBzZXRJbnB1dChpZClcbn1cblxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbGxhcHNlQnV0dG9uU3RhdHVzKGNvbGxhcHNlQnV0dG9uLCBldmVudD1udWxsKXtcbiAgICBcbiAgICAvLyBTZXQgdGV4dCBvZiBjb2xsYXBzZSBidXR0b24gdG8gXCJFeHBhbmQgQWxsXCIgaWYgZXZlbnQgaXMgXCJjb2xsYXBzZWRcIlxuICAgIGxldCBidXR0b25UZXh0ID0gY29sbGFwc2VCdXR0b24udGV4dCgpXG4gICAgXG4gICAgaWYgKGV2ZW50ID09IFwiY29sbGFwc2VkXCIpe1xuICAgICAgICBpZiAoYnV0dG9uVGV4dCA9PSBcIkV4cGFuZCBBbGxcIil7XG4gICAgICAgICAgICBjb2xsYXBzZUJ1dHRvbi50ZXh0KFwiQ29sbGFwc2UgQWxsXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsYXBzZUJ1dHRvbi50ZXh0KFwiRXhwYW5kIEFsbFwiKVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudCA9PSBcImV4cGFuZGVkXCIpe1xuICAgICAgICBpZiAoYnV0dG9uVGV4dCA9PSBcIkV4cGFuZCBBbGxcIil7XG4gICAgICAgICAgICBjb2xsYXBzZUJ1dHRvbi50ZXh0KFwiQ29sbGFwc2UgQWxsXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xsYXBzZUJ1dHRvbi50ZXh0KFwiRXhwYW5kIEFsbFwiKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBcbn1cbi8qKlxuICogPiBUaGUgZnVuY3Rpb24gYHBhcnNlVHJlZWAgdGFrZXMgdHdvIGFyZ3VtZW50cywgYGNob2ljZXNgIGFuZCBgbGV2ZWxzYCwgYW5kIHJldHVybnMgYSBuZXcgaW5zdGFuY2VcbiAqIG9mIHRoZSBgQ29uc3RydWN0VHJlZWAgY2xhc3NcbiAqIEBwYXJhbSBjaG9pY2VzIC0gYW4gT2JqZWN0IHdpdGggdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gbGV2ZWxzIC0gdGhlIG51bWJlciBvZiBsZXZlbHMgaW4gdGhlIHRyZWVcbiAqIEByZXR1cm5zIEEgQ29uc3RydWN0VHJlZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gcGFyc2VUcmVlKGNob2ljZXMsIGxldmVscyl7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RUcmVlKGNob2ljZXMsIGxldmVscylcbn1cblxuLyoqXG4gKiA+IFRoaXMgZnVuY3Rpb24gdGFrZXMgYSB0cmVlIE9iamVjdCBhbmQgYXBwZW5kcyB0aGUgbm9kZXMgdG8gdGhlIERPTVxuICogQHBhcmFtIHBhcmVudCAtIHRoZSBwYXJlbnQgZWxlbWVudCB0byBhcHBlbmQgdGhlIG5vZGVzIHRvXG4gKiBAcGFyYW0gdHJlZSAtIHRoZSB0cmVlIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBlbmROb2RlcyhwYXJlbnQsIHRyZWUsIGluY2x1ZGVNb2RlKSB7XG4gICAgY29uc29sZS5sb2coXCJBcHBlbmRpbmcgdG8gcGFyZW50OiBcIilcbiAgICBsZXQgYmFzZSA9ICQocGFyZW50KVxuXG4gICAgYmFzZS5hcHBlbmQoJChcIjx1bD5cIiwge1wiY2xhc3NcIjogc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QsIFwiaWRcIjogXCJncm91cGVkLWNoZWNrYm94LWxpc3QtYmFzZVwifSkpXG5cblxuICAgIGxldCBxdWV1ZSA9IFtdXG5cbiAgICBxdWV1ZS5wdXNoKHRyZWUucm9vdClcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaXplID0gcXVldWUubGVuZ3RoXG4gICAgICAgIGxldCBjdXJyZW50XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBxdWV1ZS5zaGlmdCgpXG5cbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGN1cnJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQudmFsdWUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmh0bWxJRCA9IGNvbnN0cnVjdE5vZGUoY2hpbGQudmFsdWUsIG51bGwsIGNoaWxkLmhhc19jaGlsZHJlbiwgYmFzZSwgaW5jbHVkZU1vZGUpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmh0bWxJRCA9IC8qIENyZWF0aW5nIGEgbmV3IG5vZGUgd2l0aCB0aGUgbmFtZSBvZiB0aGUgbm9kZSBiZWluZyB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQgYW5kIHRoZSB2YWx1ZSBiZWluZyB0aGUgc2Vjb25kIGFyZ3VtZW50LiAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3ROb2RlKGNoaWxkLnZhbHVlLCBjaGlsZC5wYXJlbnQsIGNoaWxkLmhhc19jaGlsZHJlbiwgYmFzZSwgaW5jbHVkZU1vZGUpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBJdCBjcmVhdGVzIGEgbmV3IG5vZGUsIGFzc2lnbnMgaXQgYW4gSUQsIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIG5vZGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBub2RlUGFyZW50IC0gVGhlIHBhcmVudCBub2RlIG9mIHRoZSBub2RlIHlvdSdyZSBjcmVhdGluZy5cbiAqIEBwYXJhbSBoYXNDaGlsZHJlbiAtIGJvb2xlYW5cbiAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgbm9kZSB0aGF0IHdhcyBqdXN0IGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdE5vZGUobm9kZU5hbWUsIG5vZGVQYXJlbnQsIGhhc0NoaWxkcmVuLCBiYXNlLCBpbmNsdWRlKXtcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHVzZXMgcGxhaW4gSlMgd2hpY2ggaW5jcmVhc2VzIHRoZSBzcGVlZCBpdCB0YWtlcyB0byByZW5kZXIgdGhlIG5vZGVzIGJ5IGZvdXIgdGltZXMgaW4gY29tcGFyaXNvblxuICAgIC8vIHdpdGggdGhlIG1vcmUgcmVhZGFibGUganF1ZXJ5ICAgIFxuXG4gICAgLy8gQ3JlYXRlIGEgdmFyaWFibGUgY2FsbGVkIHBhcmVudCBjb250YWluaW5nIHRoZSBkb20gb2JqZWN0IHdoaWNoIGlzIHRoZSBpZCAnZ3JvdXBlZC1jaGVja2JveC1saXN0LWJhc2UnXG5cblxuICAgIGxldCBwYXJlbnQ7XG4gICAgaWYgKCFub2RlUGFyZW50KXtcbiAgICAgICAgcGFyZW50ID0gYmFzZS5jaGlsZHJlbigkKFwiLlwiICsgc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpKVswXVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IGJhc2UuZmluZChcIiNjaGVja2JveC1saXN0LVwiICsgbm9kZVBhcmVudC5odG1sSUQpWzBdXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIElEIGZvciB0aGUgbm9kZXNcbiAgICBsZXQgbk5vZGVzID0gZ2VuZXJhdGVJRCgpXG4gICAgbGV0IG5ld05vZGVJRCA9IFwibm9kZS1cIiArIG5Ob2Rlc1xuXG4gICAgbGV0IG5vZGVMaXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKVxuXG5cbiAgICAvLyBDcmVhdGUgbm9kZSBhbmQgYXNzaWduIGNsYXNzZXNcbiAgICBsZXQgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgbm9kZS5jbGFzc0xpc3QuYWRkKFwiR3JvdXBlZENoZWNrQm94LW5vZGVcIiwgXCJ0ZXh0LWZnXCIpXG4gICAgbm9kZS5pZCA9IG5ld05vZGVJRFxuXG5cbiAgICBpZiAoaGFzQ2hpbGRyZW4pe1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNyZWF0ZUNhcmV0KCkpXG4gICAgfSBcblxuXG4gICAgLy8gQWRkIHRoZSBjaGVja2JveCBhbmQgbGFiZWwgY29tcG9uZW50XG4gICAgbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVJbnB1dENoZWNrYm94KG5vZGVOYW1lLCBuTm9kZXMpKVxuXG5cbiAgICAvLyBJZiBpbmNsdWRlIGlzIHRydWUsIGFkZCBpbmNsdWRlL2V4Y2x1ZGUgYnV0dG9uXG4gICAgaWYgKGluY2x1ZGUgPT0gdHJ1ZSl7XG4gICAgICAgIGxldCBpbmNsdWRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKVxuICAgICAgICBpbmNsdWRlQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJidG5cIiwgXCJidG4tb3V0bGluZS1zdWNjZXNzXCIsIFwiYnRuLXNtXCIsIFwibXQtMFwiLCBzdHlsZXMuYnRuSW5jbHVkZSlcbiAgICAgICAgaW5jbHVkZUJ1dHRvbi5pbm5lckhUTUwgPSBcIklOQ0xVREVcIlxuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGluY2x1ZGVCdXR0b24pXG4gICAgfVxuXG5cblxuICAgIG5vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlQ2hlY2tib3hMYWJlbChub2RlTmFtZSwgbk5vZGVzKSlcbiAgICAgICAgXG5cbiAgICBpZiAoaGFzQ2hpbGRyZW4pe1xuICAgICAgICBsZXQgbmV3TGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKVxuICAgICAgICBuZXdMaXN0LmNsYXNzTGlzdC5hZGQoc3R5bGVzLmdyb3VwZWRDaGVja2JveExpc3QpXG4gICAgICAgIG5ld0xpc3QuaWQgPSBcImNoZWNrYm94LWxpc3QtXCIgKyBuZXdOb2RlSURcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdMaXN0KVxuICAgIH1cblxuICAgIG5vZGVMaXN0RWxlbWVudC5hcHBlbmRDaGlsZChub2RlKVxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlTGlzdEVsZW1lbnQpXG5cbiAgICByZXR1cm4gbmV3Tm9kZUlEXG59XG5cbi8vIENoZWNrIGlmIGJ0biBzdGF0ZSBpcyB2YWxpZCBhbmQgc2V0IHJpZ2h0IGNsYXNzZXMuXG5mdW5jdGlvbiBzZXRCdG5TdGF0ZShidG4sIHN0YXRlKXtcbiAgICBjb25zdCBhbGxvd2VkU3RhdGVzID0gW1wiSU5DTFVERVwiLCBcIkVYQ0xVREVcIiwgXCItXCJdXG4gICAgaWYgKCFhbGxvd2VkU3RhdGVzLmluY2x1ZGVzKHN0YXRlKSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLlwiKVxuICAgIH1cblxuICAgIGJ0bi50ZXh0KHN0YXRlKVxuXG5cbiAgICBpZiAoc3RhdGUgPT0gXCJJTkNMVURFXCIpe1xuICAgICAgICBidG4ucmVtb3ZlQ2xhc3MoXCJidG4tb3V0bGluZS1kYW5nZXJcIilcbiAgICAgICAgYnRuLnJlbW92ZUNsYXNzKHN0eWxlcy5idG5JbmRldGVybWluYXRlKVxuICAgICAgICBidG4uYWRkQ2xhc3MoXCJidG4tb3V0bGluZS1zdWNjZXNzXCIpXG5cbiAgICB9IGVsc2UgaWYgKHN0YXRlID09IFwiRVhDTFVERVwiKXtcbiAgICAgICAgYnRuLnJlbW92ZUNsYXNzKFwiYnRuLW91dGxpbmUtc3VjY2Vzc1wiKVxuICAgICAgICBidG4ucmVtb3ZlQ2xhc3Moc3R5bGVzLmJ0bkluZGV0ZXJtaW5hdGUpXG4gICAgICAgIGJ0bi5hZGRDbGFzcyhcImJ0bi1vdXRsaW5lLWRhbmdlclwiKVxuXG4gICAgfSAgIGVsc2UgaWYgKHN0YXRlID09IFwiLVwiKXtcbiAgICAgICAgYnRuLnJlbW92ZUNsYXNzKFwiYnRuLW91dGxpbmUtc3VjY2Vzc1wiKVxuICAgICAgICBidG4ucmVtb3ZlQ2xhc3MoXCJidG4tb3V0bGluZS1kYW5nZXJcIilcbiAgICAgICAgYnRuLmFkZENsYXNzKHN0eWxlcy5idG5JbmRldGVybWluYXRlKVxuICAgIH1cbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIGJ1bmNoIG9mIGlucHV0cywgY3JlYXRlcyBhIHRyZWUsIGFuZCB0aGVuIHJlbmRlcnMgaXRcbiAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgZWxlbWVudCB0aGF0IHdpbGwgaG9sZCB0aGUgdHJlZVxuICogQHBhcmFtIGxhYmVsIC0gVGhlIGxhYmVsIGZvciB0aGUgdHJlZVxuICogQHBhcmFtIGNob2ljZXMgLSBBIGxpc3Qgb2YgY2hvaWNlcy4gRWFjaCBjaG9pY2UgaXMgYSBsaXN0IG9mIGxlbmd0aCAyLCB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpc1xuICogdGhlIHZhbHVlIG9mIHRoZSBjaG9pY2UsIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlIGxhYmVsLlxuICogQHBhcmFtIGxldmVscyAtIEEgdmVjdG9yIG9mIHN0cmluZ3MgdGhhdCBpbmRpY2F0ZSB0aGUgbGV2ZWxzIG9mIHRoZSB0cmVlLlxuICogQHBhcmFtIGNvbGxhcHNlZCAtIGEgYm9vbGVhbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgdHJlZSBzaG91bGQgYmUgY29sbGFwc2VkIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSBzZWxlY3RlZCAtIEEgdmVjdG9yIG9mIHZhbHVlcyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZCwgSWYgcHJvdmlkZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJlZShpZCwgbGFiZWwsIGNob2ljZXMsIGxldmVscywgY29sbGFwc2VkLCBzZWxlY3RlZCwgaW5jbHVkZU1vZGUpIHtcblxuICAgIGxldCBiYXNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpXG5cblxuXG4gICAgLy8gQ3JlYXRlIGxhYmVsXG4gICAgaWYgKGxhYmVsKXtcbiAgICAgICAgbGV0IG5ld19sYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoNFwiKTtcbiAgICAgICAgbmV3X2xhYmVsLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgICBiYXNlLmFwcGVuZENoaWxkKG5ld19sYWJlbClcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgc2VsZWN0IGJ1dHRvbnNcbiAgICAkKFwiI1wiICsgaWQpLmFwcGVuZChnZW5lcmF0ZVNlbGVjdEJ1dHRvbnMoKSlcblxuXG4gICAgbGV0IHRyZWUgPSBwYXJzZVRyZWUoY2hvaWNlcywgbGV2ZWxzKVxuXG4gICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIHRoYXQgaG9sZHMgdGhlIG5vZGVzXG4gICAgbGV0IG5vZGVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgbm9kZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHN0eWxlcy5ncm91cGVkQ2hlY2tib3hOb2RlSG9sZGVyKVxuICAgIG5vZGVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm92ZXJmbG93LWF1dG9cIilcbiAgICBub2RlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJhbGlnbi1zZWxmLWNlbnRlclwiKVxuICAgIGJhc2UuYXBwZW5kQ2hpbGQobm9kZUNvbnRhaW5lcilcblxuXG4gICAgLy8gUmVuZGVyIGFuZCBhcHBlbmQgdGhlIG5vZGVzXG4gICAgYXBwZW5kTm9kZXMobm9kZUNvbnRhaW5lciwgdHJlZSwgaW5jbHVkZU1vZGUpXG5cblxuXG4gICAgLy8gSGlkZSB0aGUgbm9kZXNcbiAgICBpZiAodHlwZW9mKGNvbGxhcHNlZCkgPT09IFwiYm9vbGVhblwiICYmIGNvbGxhcHNlZCl7XG4gICAgICAgICQoXCIjXCIgKyBpZCkuZmluZChcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hDYXJldCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgaGlkZUxpc3RFbGVtZW50KHRoaXMsIFwidG9nZ2xlXCIpXG4gICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZihjb2xsYXBzZWQpID09PSBcInN0cmluZ1wiKXtcbiAgICAgICAgICAgIGNvbGxhcHNlZCA9IFtjb2xsYXBzZWRdXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgY29sbGFwc2VkKXtcbiAgICAgICAgICAgIGxldCBjYXJldCA9ICQoXCIjXCIgKyBpZCkuZmluZChcImlucHV0W3ZhbHVlPSdcIiArIHZhbHVlICsgXCInXVwiKS5zaWJsaW5ncyhcIi5cIiArIHN0eWxlcy5ncm91cGVkQ2hlY2tib3hDYXJldCk7XG4gICAgICAgICAgICBoaWRlTGlzdEVsZW1lbnQoY2FyZXQsIFwidG9nZ2xlXCIpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayB3aGljaCBub2RlcyBzaG91bGQgYmUgc2VsZWN0ZWRcbiAgICBpZiAodHlwZW9mKHNlbGVjdGVkKSA9PT0gXCJib29sZWFuXCIgJiBzZWxlY3RlZCA9PT0gdHJ1ZSl7XG4gICAgICAgICQoXCIjXCIgKyBpZCkuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWlucHV0XCIpLnByb3Aoe2luZGV0ZXJtaW5hdGU6IGZhbHNlLCBjaGVja2VkOiB0cnVlfSl9XG4gICAgZWxzZXtcblxuICAgICAgICAvLyBJZiBzZWxlY3RlZCBpcyBhIHN0cmluZyBwdXQgaXQgaW50byBhbiBhcnJheVxuICAgICAgICBpZiAodHlwZW9mKHNlbGVjdGVkKSA9PT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IFtzZWxlY3RlZF1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIHNlbGVjdGVkKXtcbiAgICAgICAgICAgICQoXCIjXCIgKyBpZCkuZmluZChcIi5ncm91cGVkLWNoZWNrYm94LWlucHV0W3ZhbHVlPSdcIiArIHZhbHVlICsgXCInXVwiKS5wcm9wKHtpbmRldGVybWluYXRlOiBmYWxzZSwgY2hlY2tlZDogdHJ1ZX0pXG4gICAgICAgIH1cbiAgICB9XG4gICAgJChkb2N1bWVudCkub24oXCJzaGlueTpjb25uZWN0ZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVyRXZlbnRzKGlkKVxuICAgIH0pO1xuXG59XG5cblxuZXhwb3J0IHtjcmVhdGVUcmVlfSIsIm1vZHVsZS5leHBvcnRzID0gSFRNTFdpZGdldHM7IiwibW9kdWxlLmV4cG9ydHMgPSBTaGlueTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCJpbXBvcnQgJ3dpZGdldHMnO1xuaW1wb3J0ICdzaGlueSc7XG5cbmltcG9ydCB7Y3JlYXRlVHJlZX0gZnJvbSBcIi4uL21vZHVsZXMvcmVuZGVyVHJlZS5qc1wiO1xuXG5IVE1MV2lkZ2V0cy53aWRnZXQoe1xuXG4gIG5hbWU6ICd0cmVlY2hlY2tib3gnLFxuXG4gIHR5cGU6ICdvdXRwdXQnLFxuXG4gIGZhY3Rvcnk6IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAvLyBUT0RPOiBkZWZpbmUgc2hhcmVkIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZVxuXG4gICAgcmV0dXJuIHtcblxuICAgICAgcmVuZGVyVmFsdWU6IGZ1bmN0aW9uKHgpIHtcblxuICAgICAgICBjcmVhdGVUcmVlKGVsLmlkLCB4LmxhYmVsLCB4LmNob2ljZXMsIHgubGV2ZWxzLCB4LmNvbGxhcHNlZCwgeC5zZWxlY3RlZCwgeC5pbmNsdWRlTW9kZSlcblxuICAgICAgICAvLyBIVE1MV2lkZ2V0cy53aWRnZXQgc2V0cyBhIGRlZmF1bHQgc2l6ZS4gUmVtb3ZlIHRoaXMgZGVmYXVsdCBzaXplIGFuZCBtYWtlIGF1dG8uXG4gICAgICAgICQoXCIjXCIgKyBlbC5pZCkuY3NzKFwiaGVpZ2h0XCIsIFwiYXV0b1wiKS5jc3MoXCJ3aWR0aFwiLCBcImF1dG9cIilcbiAgICAgIH0sXG5cbiAgICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXG4gICAgICAgIC8vIFRPRE86IGNvZGUgdG8gcmUtcmVuZGVyIHRoZSB3aWRnZXQgd2l0aCBhIG5ldyBzaXplXG5cbiAgICAgIH1cblxuICAgIH07XG4gIH1cbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9